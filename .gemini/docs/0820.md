# 数据转换模块详细设计

## 2.1 数据转换
#### 2.1.1 模块说明
`DataConvert.m` 是一个核心的数据转换和预处理脚本，负责将原始的 `.blf` 和 `.mf4` 格式数据转换为 `.mat` 格式，并进行文件组织和命名规范化，以便后续的仿真或分析使用。它支持批量处理模式和快速转换模式，并根据车辆模型类型对文件进行特殊处理。

#### 2.1.2 重点逻辑
1.  **临时目录管理与文件准备：** 根据 `sw_QuickConvert` 变量，创建或清理 `Data/blfdata/ConversionData_tmp` 临时目录，并将原始 `.blf` 和 `.mf4` 文件移动或复制到该目录。
2.  **文件分组与命名规范化：** 遍历文件列表，根据日期和特定标识符（如 `Acore_XCP.mf4`）对文件进行分组和重命名，处理时间戳接近的文件合并逻辑。
3.  **车辆模型特定文件处理：** 根据文件内容判断车辆模型类型（例如是否包含 `ADASECU_6jikuSRS_CAN`），并对相关文件进行特定的重命名操作。
4.  **MF4 和 CAN 数据转换：**
    *   **批量模式 (`sw_BatchMode == 1`)：** 使用 `batch` 命令在后台异步执行 `MF4Convert.m` 进行 MF4 数据转换，并同步执行 `CANConvert.m` 进行 CAN 数据转换。转换完成后，调用 `startEditMatData.m` 对 MF4 转换结果进行进一步处理。
    *   **非批量模式 (`sw_BatchMode == 0`)：** 直接顺序调用 `MF4Convert()` 和 `CANConvert()` 进行数据转换。
5.  **转换结果的组织与复制：** 创建 `Data/matdata` 和子目录，将转换后的 `.mat` 文件从临时转换目录复制到最终的数据存储目录，并根据 `sw_QuickConvert` 和 `sw_dataVer` 进行不同的复制策略。
6.  **元数据保存：** 记录 MF4 文件与日期列表的关联信息到 `mf4_file_list.mat`。
7.  **清理：** 根据 `sw_QuickConvert` 的设置，调用 `revert_sorece_file()` 或删除临时目录。

#### 2.1.3 模块内部交互
`DataConvert.m` 脚本通过 `cd` 命令切换工作目录，并直接调用了以下外部 MATLAB 脚本或函数：
*   `MF4Convert.m`：负责 MF4 数据的具体转换逻辑。
*   `CANConvert.m`：负责 CAN 数据的具体转换逻辑。
*   `startEditMatData.m`：用于对 MF4 转换后的数据进行编辑或后处理。
*   `revert_sorece_file.m`：用于清理临时文件或恢复源文件。

#### 2.1.4 关键伪代码

matlab
% DataConvert.m - 核心数据转换与预处理脚本

% 1. 临时目录管理与文件准备
if sw_QuickConvert == 1
    % 快速模式：创建临时目录，移动文件
    if ~exist('./Data/blfdata/ConversionData_tmp','dir')
        mkdir('./Data/blfdata/ConversionData_tmp');
    end
    % 遍历 .blf 和 .mf4 文件，移动到临时目录
    for i = 1:length(inputdatalist)
        movefile(append(inputDirPath, inputdatalist(i)), append(inputDirPath, 'ConversionData_tmp\', inputdatalist(i)));
    end
else % sw_QuickConvert == 0
    % 标准模式：清理并创建临时目录，复制文件
    if exist('./Data/blfdata/ConversionData_tmp','dir')
        rmdir('./Data/blfdata/ConversionData_tmp', 's');
    end
    mkdir('./Data/blfdata/ConversionData_tmp');
    % 遍历 .blf 和 .mf4 文件，复制到临时目录
    for i = 1:length(inputdatalist)
        copyfile(append(inputDirPath, inputdatalist(i)), append(inputDirPath, 'ConversionData_tmp\', inputdatalist(i)));
    end
end
inputDirPath = append(inputDirPath, 'ConversionData_tmp\');

% 2. 文件分组与命名规范化 (简化伪代码)
for h = 1:length(Blf_date_list)
    files_for_date = inputdatalist(contains(inputdatalist, Blf_date_list{h}));
    % ... 复杂的日期和文件名处理逻辑，包括时间戳检查和文件重命名 ...
end

% 3. 车辆模型特定文件处理 (简化伪代码)
for h = 1:length(Blf_date_list)
    sw_VehicleMdl = 0; % 默认 2YC
    for k = 1:length(Blf_date_list_Tmp{h,1})
        if contains(Blf_date_list_Tmp{h,1}(k), 'ADASECU_6jikuSRS_CAN')
            sw_VehicleMdl = 1; % MPU 相关
        end
    end
    if sw_VehicleMdl == 1
        % 执行特定文件重命名
    end
end

% 4. MF4 和 CAN 数据转换
if sw_BatchMode == 1
    % 批量模式
    cd('./Convert/');
    job = batch('MF4Convert', 'Workspace', workspaceVars); % 异步执行 MF4 转换
    % CAN 数据转换
    for CANi = 1:length(ResimDate_list)
        CANConvert(); % 调用 CAN 转换脚本
    end
    wait(job, "finished"); % 等待 MF4 转换完成
    resultVar = fetchOutputs(job);
    assignin('base', 'resultVar', resultVar);
    cd('./MF4/');
    cd('./margeMatData_Acore/');
    startEditMatData(); % 调用 MF4 后处理脚本
    if sw_GcoreData == 1
        cd('../margeMatData_Gcore/');
        startEditMatData(); % 调用 Gcore MF4 后处理脚本
    end
    cd(currentDir); cd('./Convert/');
else % sw_BatchMode == 0
    % 非批量模式
    cd('./Convert/');
    MF4Convert(); % 直接调用 MF4 转换脚本
    % CAN 数据转换
    for CANi = 1:length(ResimDate_list)
        CANConvert(); % 调用 CAN 转换脚本
    end
end

% 5. 转换结果的组织与复制 (简化伪代码)
cd(currentDir);
mkdir('./Data/matdata'); % 创建最终数据目录
mkdir('./Data/blfdata/ConvertedData/2YCkai');
mkdir('./Data/blfdata/ConvertedData/MAPvcl');

% 复制转换后的 .mat 文件到 Data/matdata
% copyfile(source_mf4_mat, destination_mf4_mat);
% copyfile(source_can_mat, destination_can_mat);

% 复制 .blf 文件到 Data/blfdata/ConvertedData/
% copyfile(source_blf, destination_blf);

% 6. 元数据保存
% ... 保存 mf4_file_list.mat ...

% 7. 清理
if sw_QuickConvert == 1
    cd(fullfile(currentDir,'Convert'));
    revert_sorece_file(fullfile(currentDir,'Data','blfdata')); % 调用清理脚本
    cd(currentDir);
else
    cd(currentDir);
    if exist('./Data/blfdata/ConversionData_tmp','dir')
        rmdir('./Data/blfdata/ConversionData_tmp', 's'); % 删除临时目录
    end
end


---

### 2.2 MF4Convert.m

#### 2.2.1 模块说明
`MF4Convert.m` 脚本负责将原始的 `.mf4` 数据文件转换为 `.mat` 格式，以便后续在 MATLAB 环境中进行处理和分析。它通过调用外部可执行程序 (`mf4conv_all.exe` 和 `mf4_thread.exe`) 来完成实际的转换工作，并根据配置（快速转换模式或标准模式）选择不同的转换策略。

#### 2.2.2 重点逻辑
1.  **环境初始化与清理：** 脚本首先切换到 `./MF4/` 目录，并清理旧的转换日志 (`ConvertLog`)。它还会检查并清理 `LogRemap` 目录中不再需要的已转换 `.mat` 文件，确保只保留与当前 `Blf_date_list` 相关的最新数据。
2.  **路径配置：** 定义了源文件路径 (`SOURCE_PATH`)、MF4 转换工具路径 (`EXE_PATH`)、转换后 `.mat` 文件的输出路径 (`REMAP_PATH`) 和转换日志的输出路径 (`CONVERT_LOG_PATH`)。
3.  **文件列表准备：** 根据 `Blf_date_list` 构建需要转换的 ACore MF4 文件列表 (`_ACore_XCP.mf4`)。
4.  **MF4 转换过程：**
    *   **快速转换模式 (`sw_QuickConvert == 1`)：** 识别出尚未转换的 MF4 文件，将这些文件列表写入一个 JSON 文件，然后调用 `mf4_thread.exe`（一个多线程工具）来并行执行 `mf4conv_all.exe` 进行批量转换。这种模式旨在提高转换效率。
    *   **标准转换模式 (`sw_QuickConvert == 0`)：** 遍历每个 MF4 文件，并使用 `system` 命令逐个调用 `mf4conv_all.exe` 进行转换。转换过程的输出会被重定向到日志文件。
5.  **Gcore 数据转换：** 如果 `sw_GcoreData` 为 1，脚本会执行类似的转换流程，处理 `_GCore_XCP.mf4` 文件。
6.  **后处理调用（非批量模式）：** 在非批量模式下，它会切换到 `margeMatData_Acore/` 和 `margeMatData_Gcore/` 目录，并调用 `startEditMatData()` 脚本，对转换后的 `.mat` 数据进行进一步的合并或编辑。

#### 2.2.3 模块内部交互
`MF4Convert.m` 脚本主要通过 `system` 命令与外部可执行程序进行交互，并调用了 `startEditMatData.m` 脚本进行后处理。

#### 2.2.4 关键伪代码

matlab
% MF4Convert.m - MF4 数据转换脚本

% 1. 环境初始化与清理
cd('./MF4/');
if exist('./ConvertLog','dir')
    rmdir('./ConvertLog/', 's');
end
% ... 清理 LogRemap 目录中旧的或不相关的 .mat 文件 ...

% 2. 路径配置
SOURCE_PATH = inputDirPath; % 从 DataConvert.m 传入
EXE_PATH = fullfile(pwd, 'mf4conv_all.exe');
REMAP_PATH = fullfile(pwd, 'LogRemap');
CONVERT_LOG_PATH = fullfile(pwd, 'ConvertLog');

% 确保输出目录存在
if ~exist(REMAP_PATH, 'dir')
    mkdir(REMAP_PATH);
end
if ~exist(CONVERT_LOG_PATH, 'dir')
    mkdir(CONVERT_LOG_PATH);
end

% 3. 文件列表准备 (ACore)
for h = 1:length(Blf_date_list)
    fileList(h,1)      = append(SOURCE_PATH, Blf_date_list(h), '_ACore_XCP.mf4');
    fileList_name(h,1) = append(Blf_date_list(h), '_ACore_XCP.mf4');
end

% 4. MF4 转换逻辑
if sw_QuickConvert == 1
    % 快速转换模式 (多线程)
    % 识别需要转换的文件
    % fileList_need_convert = ...
    
    if ~isempty(fileList_need_convert)
        % 将文件列表写入 JSON
        % mf4JsonString = jsonencode(mf4DataStruct);
        % fileID = fopen(Mf4JsonFilename, 'w');
        % fprintf(fileID, '%s\n', mf4JsonString);
        % fclose(fileID);
        
        % 调用多线程转换工具
        ThreadPoolEXEPath = fullfile(pwd, 'mf4_thread.exe');
        ThreadPoolCommand = sprintf('%s %s %s %s %s %s', ThreadPoolEXEPath, EXE_PATH, REMAP_PATH, CONVERT_LOG_PATH, Mf4JsonFilename);
        system(ThreadPoolCommand);
        delete(Mf4JsonFilename); % 删除临时 JSON 文件
    end
else % sw_QuickConvert == 0
    % 标准转换模式 (单线程)
    for i = 1:length(fileList)
        filePath = fileList(i,1);
        % 调用外部转换工具，输出日志
        system(sprintf('%s %s %s > %s\\%s_convert.log', EXE_PATH, filePath, REMAP_PATH, CONVERT_LOG_PATH, fileList_name(i,1)));
    end
end

% 5. Gcore 数据转换 (如果 sw_GcoreData == 1)
if sw_GcoreData == 1
    % 类似 ACore 转换，构建 GCore 文件列表并调用外部工具进行转换
    % ...
end

% 6. 后处理调用 (仅在非批量模式下)
if sw_BatchMode == 0
    cd('./margeMatData_Acore/');
    startEditMatData(); % 调用 ACore 后处理脚本
    if sw_GcoreData == 1
        cd('../margeMatData_Gcore/');
        startEditMatData(); % 调用 GCore 后处理脚本
    end
end

% 7. 恢复目录
cd(currentDir); cd('./Convert/');


---

### 2.3 CANConvert.m

#### 2.3.1 模块说明
`CANConvert.m` 脚本负责将不同类型的 CAN `.blf` 日志文件转换为 `.mat` 格式。它处理多种 CAN 数据流，包括 `ADASECU_CAN`、`MPU_CAN`、`VEHICLE_CAN` 和 `MPU_message12`。该脚本能够处理单个 `.blf` 文件，也能将多个相关的 `.blf` 文件合并成一个 `.mat` 文件。其核心功能依赖于外部的 `convertBlf` 函数进行实际的转换，以及 `merge` 函数进行数据合并。

#### 2.3.2 重点逻辑
1.  **环境设置：** 脚本首先切换到 `./CAN/SimScript/` 目录，并将该目录及其子目录添加到 MATLAB 路径中，以确保 `convertBlf` 和 `merge` 函数能够被正确调用。
2.  **分类型转换：** 脚本为每种 CAN 数据类型（ADASECU_CAN, MPU_CAN, VEHICLE_CAN, MPU_message12）设置了独立的转换逻辑块。
3.  **文件命名与存在性检查：** 在每个转换块中，脚本会根据当前处理的 BLF 文件列表和 CAN 类型构建目标 `.mat` 文件的名称。在执行转换之前，它会检查目标 `.mat` 文件是否已经存在，如果存在则跳过转换，实现增量处理。
4.  **`convertBlf` 调用：** 这是 BLF 到 MAT 转换的核心步骤。脚本会准备好 BLF 文件名列表 (`blfName`)、BLF 文件路径 (`blfPath`) 和一个 `swMPUmessage` 标志，然后调用 `convertBlf(blfName, blfPath, swMPUmessage)` 函数。在调用前后会打印日志信息，并在转换完成后删除 `BLFconverter.exe` 和 `zlib.dll`，这表明 `convertBlf` 可能在内部使用了这些外部可执行文件。
5.  **`merge` 调用：** 如果 `blfName` 包含多个 BLF 文件（即 `size(blfName, 1) > 1`），脚本会调用 `merge(blfName, merge_Type)` 函数。`merge_Type` 是一个整数，用于指示要合并的 CAN 数据类型（例如，1 用于 ADASECU_CAN 和 MPU_CAN，2 用于 VEHICLE_CAN，3 用于 MPU_message12）。这表明 `merge` 函数负责将由 `convertBlf` 生成的多个 `.mat` 文件合并成一个。
6.  **目录恢复：** 完成所有转换后，脚本会切换回 `currentDir`，然后回到 `./Convert/` 目录。

#### 2.3.3 模块内部交互
`CANConvert.m` 主要通过调用 `convertBlf.m` 和 `merge.m` 这两个函数来完成其功能。它还隐式地依赖于 `BLFconverter.exe` 和 `zlib.dll`，这些文件可能由 `convertBlf.m` 在内部使用。

#### 2.3.4 关键伪代码

matlab
% CANConvert.m - CAN 数据转换脚本

% 1. 环境设置
cd('./CAN/SimScript/');
addpath(genpath(pwd)); % 将当前目录及其子目录添加到 MATLAB 路径

% 2. ADASECU_CAN 转换
% 构建文件名，检查文件是否存在
if ~exist(target_adasecu_mat_file, 'file')
    % 准备 blfName (例如：'20230101_120000_ADASECU_CAN')
    
    % 调用核心 BLF 转换函数
    fprintf(1,'Blf Convert Start\n');
    reBlfName = convertBlf(blfName, blfPath, 0); % swMPUmessage = 0
    fprintf(1,'Blf Convert End\n');
    delete BLFconverter.exe zlib.dll; % 清理临时文件
    
    % 如果有多个 BLF 文件，则合并
    if 1 < size(blfName, 1)
        cd('../'); % 切换到 ./CAN/
        ADASECU_CAN_merge = merge(blfName, 1); % merge_Type = 1
    end
end

% 3. MPU_CAN 转换 (条件：sw_dataVer == 0)
if sw_dataVer == 0
    % 类似 ADASECU_CAN 转换逻辑
end

% 4. VEHICLE_CAN 转换 (条件：sw_VEHICLE == 1)
if sw_VEHICLE == 1
    % 类似 ADASECU_CAN 转换逻辑
end

% 5. MPU_message12 转换
% 类似 ADASECU_CAN 转换逻辑
% ... 调用 convertBlf (swMPUmessage = 1) ...
% ... 如果有多个 BLF 文件，则调用 merge (merge_Type = 3) ...

% 6. 目录恢复
cd(currentDir);
cd('./Convert/');


---

### 2.4 convertBlf.m

#### 2.4.1 模块说明
`convertBlf.m` 是一个核心函数，用于将单个或多个 `.blf` 文件转换为 MATLAB 可用的数据格式（很可能是 `.mat` 文件），可能通过中间的 `.csv` 转换步骤。它处理不同类型的 BLF 数据，特别是针对 RVU 数据有特定的处理路径。该函数本身不执行实际的 BLF 解析，而是依赖于外部脚本 `dataconverter.m` 来完成这项工作。

#### 2.4.2 重点逻辑
1.  **函数签名：** 接收 `blfName`（要转换的 BLF 文件名列表）、`blfPath`（BLF 文件路径）和 `swMPUmessage`（一个标志，可能用于指示 MPU 消息处理模式）。
2.  **RVU 数据处理：** 如果 `blfName` 中不包含 'ADU'，则被视为 RVU 数据，并进行特定的初始化和排序。
3.  **临时目录管理：** 在转换开始前，会清理 `../Data/csvdata` 和 `../Data/mf4data/` 目录，这表明 `dataconverter.m` 可能会生成这些中间文件。
4.  **主转换循环：**
    *   遍历 `blfName` 中的每个 BLF 文件。
    *   **调用 `dataconverter;`：** 这是核心步骤，执行 `dataconverter.m` 脚本。这个脚本负责实际的 BLF 解析和数据生成。
    *   **输出文件名处理：** 根据 `dataconverter.m` 设置的 `fileCnt` 和 `crrChgFlg` 变量，决定是否在输出文件名中添加 `_PlusX` 后缀，以表示多个文件合并的情况。
5.  **后处理清理：** 转换完成后，删除 `../Data/csvdata` 目录。
6.  **`CompareData` 子函数：** 这是一个辅助函数，用于比较带有时间戳的文件名列表，并根据时间差（小于 90 秒）进行筛选。虽然它在主函数中没有直接调用，但可能作为其他 CAN 转换流程的实用工具。

#### 2.4.3 模块内部交互
`convertBlf.m` 的主要交互是执行 `dataconverter.m` 脚本。它还隐式依赖于 `dataconverter.m` 内部设置的 `fileCnt` 和 `crrChgFlg` 变量。

#### 2.4.4 关键伪代码

matlab
% convertBlf.m - BLF 文件转换核心函数

function reBlfName = convertBlf(blfName, blfPath, swMPUmessage)
    swAuto = 1; % 可能用于 dataconverter.m

    % RVU 数据处理 (如果 blfName 不包含 'ADU')
    if ~any(contains(blfName, 'ADU'))
        baseBlfName = 'RVU_INPUT';
        blfName = sort(blfName); % 排序 BLF 文件名

        % 清理临时目录
        if exist('../Data/csvdata', 'dir')
            rmdir('../Data/csvdata', 's');
        end
        if exist('../Data/mf4data/', 'dir')
            rmdir('../Data/mf4data/', 's');
        end

        reBlfCnt = 0;
        reBlfName{1} = '';

        % 主转换循环
        for ci = 1:length(blfName)
            fprintf(1, 'Convert %s.blf\n', blfName{ci});
            data = cellstr(blfName{ci}); % 准备数据给 dataconverter

            clear mergeFileName; % 清理变量，可能用于 dataconverter
            dataconverter; % !!! 执行实际的 BLF 转换 !!!

            % 根据 dataconverter 的结果更新输出文件名
            if (fileCnt > 1 && crrChgFlg == 1)
                reBlfCnt = reBlfCnt + 1;
                reBlfName{reBlfCnt} = strcat(blfName{ci}, '_Plus', num2str(fileCnt - 1));
            elseif (crrChgFlg == 1)
                reBlfCnt = reBlfCnt + 1;
                reBlfName{reBlfCnt} = blfName{ci};
            end
            fprintf(1, 'End %s.blf\n', blfName{ci});
        end

        % 清理临时目录
        if exist('../Data/csvdata', 'dir')
            rmdir('../Data/csvdata', 's');
        end
    end
end

% CompareData 子函数 (未在主函数中直接调用)
function tmpStrList = CompareData(List1, List2)
    % ... 时间戳比较逻辑 ...
end


---

### 2.5 dataconverter.m

#### 2.5.1 模块说明
`dataconverter.m` 是整个 BLF 数据转换流程的核心脚本。它不直接解析 BLF 文件，而是作为协调者，调用外部的 Vector CANape 工具链（`CallConverter.exe` 及其 DLLs）和专门的 MPU BLF 转换工具（`BLFconverter_MPU4th.exe`）来完成 BLF 到 MAT 格式的转换。它根据不同的 BLF 类型（通用 CAN 或 MPU 消息）执行不同的转换路径，并管理中间文件（MDF、CSV）和目录。

#### 2.5.2 重点逻辑
1.  **初始化与目录创建：** 设置 CSV 数据路径，并创建必要的 `../Data/csvdata` 和 `../Data/matdata` 目录。
2.  **通用 CAN 数据转换 (`swMPUmessage == 0` 分支)：**
    *   **工具路径配置：** 尝试定位 `CallConverter.exe`（Vector CANape 的一部分）的路径，并设置 CANape 的初始化文件 (`CANAPE_INI`)。
    *   **BLF 文件复制与预处理：** 将输入的 BLF 文件复制到临时目录，并可能根据 `fileNum` 进行文件名重命名（例如，`CAMERA_CAN` 或 `MPU_CAN`）。
    *   **BLF 到 MDF 转换：** 调用 `CallConverter.exe` 和 `canconv.dll` 将 BLF 文件转换为 MDF 格式。
    *   **MDF 到 MAT 转换：** 接着调用 `CallConverter.exe` 和 `matconv.dll` 将 MDF 文件转换为 MAT 格式。
    *   **字段重命名：** 调用 `RenameFields_r02;` 脚本对生成的 MAT 文件中的字段进行后处理。
    *   **清理：** 删除中间的 MDF 文件和临时 BLF/MAT 文件。
    *   **保存 MAT：** 将最终的 MAT 文件保存到指定的 `../Data/matdata` 目录。
3.  **MPU 消息数据转换 (`swMPUmessage == 1` 分支)：**
    *   **BLF 文件复制与预处理：** 将输入的 BLF 文件复制到临时目录，并重命名为 `_MPU_RVU_BYPASS.blf`。
    *   **BLF 到 CSV 转换：** 调用 `BLFconverter_MPU4th.exe` 将 BLF 文件转换为 CSV 格式。
    *   **CSV 文件复制：** 将生成的 CSV 文件复制到临时 `output_csv` 目录。
    *   **CSV 到 MAT 转换：** 调用 `Csv2MatForMpuRvuEther;` 脚本将 CSV 数据转换为 MAT 格式。
    *   **清理：** 删除临时 CSV 目录。
    *   **保存 MAT：** 将最终的 MAT 文件保存到指定的 `../Data/matdata` 目录。
4.  **全局变量设置：** 设置 `fileCnt` 和 `crrChgFlg` 变量，这些变量会被调用 `dataconverter.m` 的 `convertBlf.m` 函数使用。

#### 2.5.3 模块内部交互
`dataconverter.m` 主要通过 `system` 命令与外部可执行程序（`CallConverter.exe`、`BLFconverter_MPU4th.exe`）进行交互。它还调用了 `RenameFields_r02.m` 和 `Csv2MatForMpuRvuEther.m` 脚本。

#### 2.5.4 关键伪代码

matlab
% dataconverter.m - BLF 数据转换协调脚本

% 1. 初始化与目录创建
csvDataPath = '../Data/csvdata';
if exist('../Data/csvdata') == 0
    mkdir('../Data/csvdata');
end
if exist('../Data/matdata') == 0
    mkdir('../Data/matdata');
end

fileCnt = 0; % 由 convertBlf.m 使用
crrChgFlg = 1; % 由 convertBlf.m 使用

% 2. 通用 CAN 数据转换 (当 swMPUmessage == 0)
if swMPUmessage == 0
    % 设置 CallConverter.exe 路径和 CANape INI
    CALLCONVERTER_EXE = 'C:\Program Files (x86)\Vector CANape 16\Exec\CallConverter.exe';
    CANAPE_INI = '-IF:..\2QD\conv\CANape_MPU3rd.INI';

    % 复制 BLF 文件到临时目录并重命名
    
    cd('../TOOL/Converter/BLFconverterForRvuGen2/CallConverterCAN');

    % BLF 到 MDF 转换
    xxx_cmd = sprintf('"%s" -C:canconv.dll %s ./blfdata/%s.blf %s.mdf', CALLCONVERTER_EXE, CANAPE_INI, datafiles{ci}, datafiles{ci});
    system(xxx_cmd);

    % MDF 到 MAT 转换
    xxx_cmd = sprintf('"%s" -C:matconv.dll %s %s.mdf ./matdata/%s.mat ', CALLCONVERVER_EXE, CANAPE_INI, datafiles{ci}, datafiles{ci});
    system(xxx_cmd);

    RenameFields_r02; % 调用字段重命名脚本

    % 清理中间文件
    
    % 保存最终 MAT 文件
end

% 3. MPU 消息数据转换 (当 swMPUmessage == 1)
if swMPUmessage == 1
    % 复制 BLF 文件到临时目录并重命名

    cd('../TOOL/Converter/BLFconverterForRvuGen2/mpuConverter');

    % BLF 到 CSV 转换
    system(['BLFconverter_MPU4th.exe ../CallConverterCAN/blfdata/', datafilesBYPASS, '.blf ', csvDataPath]);

    % 复制 CSV 文件

    cd('CsvConverter');
    Csv2MatForMpuRvuEther; % 调用 CSV 到 MAT 转换脚本

    % 清理临时 CSV 目录

    % 保存最终 MAT 文件
end

% 清理 CALLCONVERTER_EXE 和 CANAPE_INI 变量
clear CALLCONVERTER_EXE CANAPE_INI;


---

### 2.6 RenameFields_r02.m

#### 2.6.1 模块说明
`RenameFields_r02.m` 是一个后处理脚本，用于规范化由 CANape BLF/MDF 转换生成的 `.mat` 文件中的数据结构。它的主要功能是从原始的 CANape 输出中提取时间序列数据和对应的信号值，并将它们组织成标准的 `[时间, 值]` 矩阵格式，同时对信号名称进行清理和重命名，使其更易于在 MATLAB 中使用。

#### 2.6.2 重点逻辑
1.  **数据加载：** 脚本加载由 `dataconverter.m` 生成的 `.mat` 文件（例如 `xxx_fileName.mat`）到 `xxx_dat` 结构体中。同时，它还会读取对应的 `.m` 文件（例如 `xxx_fileName.m`），这个 `.m` 文件很可能是 CANape 生成的，包含了变量的定义和结构信息。
2.  **CANape 格式转换（时间序列提取）：**
    *   脚本遍历 `.m` 文件的每一行，使用正则表达式 `'Group(\d+)Time'` 查找定义时间序列的变量（例如 `Group1Time`）。
    *   一旦找到，它会构建并执行 MATLAB 命令，将 `xxx_dat` 中对应的原始时间数据赋值给新的变量（例如 `xxx_ts1`），从而提取出时间序列。
3.  **CANape 格式转换（信号值提取与重命名）：**
    *   脚本再次遍历 `.m` 文件的每一行，使用正则表达式 `'GROUP(\d+)(:,'` 和 `'CAN(\d+)_'` 来识别信号值变量。
    *   它提取信号名称，并移除“CAN”前缀（例如，`CAN1_SignalX` 变为 `SignalX`），进行名称清理。
    *   然后，它创建一个以清理后的名称命名的新变量（例如 `SignalX`），并将其初始化为一个两列的零矩阵（用于存储时间和值）。
    *   脚本将对应的时间序列数据填充到第一列，将实际的信号值从 `xxx_dat` 填充到第二列。这样，每个信号都被转换成了一个标准的 `[时间, 值]` 矩阵。
4.  **数据保存（条件性）：**
    *   脚本包含一个条件 `if ci == 2`，这表明它可能只在特定条件下（当 `ci` 变量的值为 2 时）才保存数据。
    *   它将所有变量（除了 `filename`、`save_cmd` 和 `i`）保存到一个新的 `.mat` 文件中，文件名为 `xxx_fileName_MDFD.mat`。

#### 2.6.3 模块内部交互
`RenameFields_r02.m` 脚本通过 `load` 命令读取 `.mat` 文件，通过 `fopen` 和 `textscan` 读取 `.m` 文件，并通过 `eval` 命令动态执行 MATLAB 表达式来重构数据。它依赖于 `datafiles` 和 `ci` 变量在执行时已存在于工作空间中。

#### 2.6.4 关键伪代码

matlab
% RenameFields_r02.m - CANape 转换后数据规范化脚本

% 1. 变量加载
xxx_fileName = strcat('./matdata/', datafiles{ci});
xxx_dat = load(strcat(xxx_fileName, '.mat')); % 加载原始 .mat 文件
xxx_fileID = fopen(strcat(xxx_fileName, '.m')); % 读取对应的 .m 文件
xxx_C = textscan(xxx_fileID, '%s');
fclose(xxx_fileID);

% 2. CANape 格式转换 (时间序列提取)
for xxx_i = 1:length(xxx_C{1,1})
    xxx_expression = 'Group(\d+)Time';
    xxx_ressch = regexp(xxx_C{1,1}{xxx_i}, xxx_expression, 'tokens');
    if(~isempty(xxx_ressch))
        % 例如：xxx_ts1 = xxx_dat.Group1Time;
        xxx_cmd = sprintf('xxx_ts%s = xxx_dat.%s', char(xxx_ressch{1}), char(xxx_C{1,1}{xxx_i+2}));
        eval(xxx_cmd);
    end
    if(strfind(xxx_C{1,1}{xxx_i}, 'SigNames'))
        break; % 遇到 'SigNames' 停止
    end
end

% 3. CANape 格式转换 (信号值提取与重命名)
for xxx_i = 1:length(xxx_C{1,1})
    xxx_expression = 'GROUP(\d+)(:,';
    xxx_expression2 = 'CAN(\d+)_';
    xxx_ressch = regexp(xxx_C{1,1}{xxx_i}, xxx_expression, 'tokens');
    if(~isempty(xxx_ressch))
        xxx_name = xxx_C{1,1}{xxx_i-2};
        xxx_name = regexprep(xxx_name, xxx_expression2, ''); % 移除 'CAN' 前缀

        % 初始化信号矩阵 (例如：SignalX = zeros(length(xxx_ts1), 2);)
        xxx_cmd = sprintf('xxx_ln = length(xxx_ts%s);', char(xxx_ressch{1}));
        eval(xxx_cmd);
        xxx_cmd = sprintf('%s = zeros(xxx_ln,2);', xxx_name);
        eval(xxx_cmd);

        % 填充时间列 (例如：SignalX(:,1) = xxx_ts1;)
        xxx_cmd = sprintf('%s(:,1) = xxx_ts%s;', xxx_name, char(xxx_ressch{1}));
        eval(xxx_cmd);

        % 填充值列 (例如：SignalX(:,2) = xxx_dat.CAN1_SignalX;)
        xxx_cmd = sprintf('%s(:,2) = xxx_dat.%s', xxx_name, char(xxx_C{1,1}{xxx_i}));
        eval(xxx_cmd);
    end
    if(strfind(xxx_C{1,1}{xxx_i}, 'SigNames'))
        break; % 遇到 'SigNames' 停止
    end
end

% 4. 保存数据 (条件性)
if ci == 2
    filename = strcat(xxx_fileName, '_MDFD.mat');
    clearvars xxx_*; % 清除临时变量
    save_cmd = sprintf('save %s -regexp ^(?!(filename|save_cmd|i)$).;', filename);
    eval(save_cmd); % 保存处理后的数据
end


---

### 2.7 Csv2MatForMpuRvuEther.m

#### 2.7.1 模块说明
`Csv2MatForMpuRvuEther.m` 是一个专门用于将 MPU/RVU 相关的 CSV 数据文件转换为 MATLAB `.mat` 文件的脚本。它能够处理多种“消息”类型（MpuMessage1-4 和 RvuMessage1-4），每种消息类型可能代表一种特定的数据结构或信息。该脚本采用模块化设计，通过调用独立的子脚本（例如 `Csv2MatForMpuMessage1.m`）来完成每种消息类型的具体 CSV 解析和 MAT 转换。

#### 2.7.2 重点逻辑
1.  **初始化与路径设置：** 脚本首先清除与 MPU/RVU 消息相关的变量，并添加 `subFunctions` 目录到 MATLAB 路径，这表明具体的转换逻辑位于该子目录中。它还定义了一系列常量（例如 `LANE_NUM_MAX`），这些常量可能用于定义转换后数据结构的最大尺寸。`conv_filter` 和 `save_filter` 数组用于控制哪些消息类型需要被转换和保存。
2.  **过滤器调整：** 确保如果某个消息类型被设置为不转换，则它也不会被保存。
3.  **输出目录检查：** 如果输出目录 (`../result_mat/`) 不存在，则创建它。
4.  **消息类型特定转换循环：** 脚本为每种消息类型（MpuMessage1-4 和 RvuMessage1-4，共 8 种）都包含一个重复的结构。在每个结构中：
    *   它首先检查 `conv_filter` 以确定是否需要转换该消息。
    *   然后，它根据消息类型查找对应的 CSV 文件（例如 `MpuMessage1*.csv` 或 `MpuMessageX.csv`）。
    *   使用 `importdata` 函数将 CSV 内容加载到 `in_data` 变量中。
    *   **调用子脚本：** 这是核心转换步骤，它会调用一个专门的子脚本（例如 `Csv2MatForMpuMessage1;`）来处理 `in_data` 并生成相应的 MATLAB 变量（例如 `MpuMessage1`）。
    *   **错误处理：** 包含 `try-catch` 块来处理 CSV 文件不存在的情况。
    *   **保存 MAT 文件：** 如果 `save_filter` 允许，则将生成的 MATLAB 变量保存为 `.mat` 文件到指定的输出路径。
5.  **清理：** 脚本结束时会清除大量临时变量以释放内存。

#### 2.7.3 模块内部交互
`Csv2MatForMpuRvuEther.m` 主要通过调用 `subFunctions` 目录下的各个 `Csv2MatFor...MessageX.m` 脚本来完成其功能。

#### 2.7.4 关键伪代码

matlab
% Csv2MatForMpuRvuEther.m - MPU/RVU CSV 到 MAT 转换脚本

% 1. 初始化与路径设置
clear_vars = {'MpuMessage1', 'MpuMessage2', ...}; % 清除相关变量
clear(clear_vars{:});
addpath('subFunctions'); % 添加子函数目录

% 定义常量 (例如：LANE_NUM_MAX, LANE_POINT_1_NUM_MAX)
% ...

% 定义转换和保存过滤器
conv_filter = [1 1 1 1 1 1 1 1]; % 控制是否转换
save_filter = [1 1 1 1 1 1 1 1]; % 控制是否保存
dir_path = '..\output_csv\'; % CSV 输入路径
output_path = '..\result_mat\'; % MAT 输出路径

% 2. 过滤器调整
for filter_index = 1:size(conv_filter)
    if conv_filter(filter_index) == 0
        save_filter(filter_index) = 0;
    end
end

% 3. 输出目录检查
if ~exist(output_path, 'dir')
    mkdir(output_path);
end

% 4. MpuMessage1 转换
if conv_filter(1) ~= 0
    file_names = dir(strcat(dir_path, 'MpuMessage1*.csv'));
    for j = 1:length(file_names)
        tgt_path = strcat(dir_path, file_names(j).name);
        try
            in_data = importdata(tgt_path); % 导入 CSV 数据
            Csv2MatForMpuMessage1; % !!! 调用子脚本进行转换 !!!
        catch
            disp('MpuMessage1.csv not exist.');
        end
    end
    if save_filter(1) ~= 0
        tgt_path = strcat(output_path, 'MpuMessage1.mat');
        save(tgt_path, 'MpuMessage1', '-v7.3'); % 保存 MAT 文件
    end
else
    disp('Skip convert MpuMessage1.');
end

% 5. MpuMessage2, MpuMessage3, MpuMessage4, RvuMessage1-4 转换 (类似 MpuMessage1 逻辑)
% ... 重复类似的代码块 ...

% 6. 清理
clear_vars = {'LANE_NUM_MAX', 'LANE_POINT_1_NUM_MAX', ...}; % 清除临时变量
clear(clear_vars{:});

disp('Completed...');


---

### 2.8 Csv2MatForMpuMessage1.m

#### 2.8.1 模块说明
`Csv2MatForMpuMessage1.m` 脚本负责解析 `MpuMessage1.csv` 文件（或匹配 `MpuMessage1*.csv` 的文件），并将其数据转换为一个名为 `MpuMessage1` 的结构化 MATLAB 变量。它详细定义了 `MpuMessage1` 结构中每个字段的名称、预期大小和数据类型，然后将 CSV 中的原始数据映射并填充到这个结构中，形成时间序列数据。

#### 2.8.2 重点逻辑
1.  **初始化：** 清除 `mpu_message1_elements` 变量，并初始化 `in_data_col` 为 1，作为 CSV 数据列的计数器。
2.  **消息元素定义 (`mpu_message1_elements`)：** 这是 `MpuMessage1` 结构的核心定义。它是一个单元格数组，每行定义了消息的一个字段（或“元素”），包含以下信息：
    *   **名称：** 字段的名称（例如 `'elapsedTime'`）。
    *   **数组大小：** 字段的预期数组大小。
    *   **`sigSize` 标志：** 指示是否存在关联的信号大小字段（`0` 表示没有，`1` 表示有）。
    *   **转换标志：** （在此代码中始终为 `0`，表示所有字段都需要转换）。
    *   **`sigSize` 数据类型：** 如果存在 `sigSize` 字段，其数据类型。
    *   **值数据类型：** 字段实际值的数据类型（例如 `'double'`、`'single'`）。
    *   这个定义是条件性的，取决于 `mpu_if_conv` 的值，这表明 MPU 消息可能存在不同的版本或配置。
3.  **数据解析与结构化循环：**
    *   脚本遍历 `mpu_message1_elements` 中定义的每个元素。
    *   **跳过已处理列：** 如果元素的转换标志不为 `0`，则跳过相应的 CSV 列。
    *   **根据 `sigSize` 标志进行条件处理：**
        *   **如果 `sigSize` 标志为 `0`（无 `sigSize`）：** 将 CSV 的第一列（假定为时间）填充到 `MpuMessage1.<element_name>.time` 中。将 `in_data` 中从 `in_data_col` 开始的数据填充到 `MpuMessage1.<element_name>.signals.values` 中，并进行类型转换。`in_data_col` 增加 `array_size`。
        *   **如果 `sigSize` 标志不为 `0`（有 `sigSize`）：** 首先处理 `sigSize` 字段，将其填充到 `MpuMessage1.<element_name>.sigSize.time` 和 `MpuMessage1.<element_name>.sigSize.signals.values` 中。然后，处理实际的信号值，将其填充到 `MpuMessage1.<element_name>.sigValue.time` 和 `MpuMessage1.<element_name>.sigValue.signals.values` 中。`in_data_col` 相应地增加。
    *   脚本广泛使用 `eval` 函数来动态创建字段名称并将值赋给 `MpuMessage1` 结构。
4.  **清理：** 清除局部变量。

#### 2.8.3 模块内部交互
`Csv2MatForMpuMessage1.m` 脚本直接操作从 `Csv2MatForMpuRvuEther.m` 传入的 `in_data`、`row_begin` 和 `row_num` 变量，并使用全局常量（如 `LANE_NUM_MAX`）。它不直接调用其他脚本或函数。

#### 2.8.4 关键伪代码

matlab
% Csv2MatForMpuMessage1.m - MPU Message 1 CSV 解析器

% 1. 初始化
in_data_col = 1;
clear mpu_message1_elements;

% 2. 消息元素定义 (mpu_message1_elements)
% 这是一个单元格数组，定义了 MpuMessage1 结构的每个字段
% 示例行: {'elapsedTime', 1, 0, 0, 0, 'double'}
% ... (根据 mpu_if_conv 的值定义不同的结构) ...

% 3. 数据解析与结构化循环
for i = 1:length(mpu_message1_elements)
    array_size = mpu_message1_elements{i}{2};
    
    % 跳过不需要转换的列
    if mpu_message1_elements{i}{4} ~= 0
        if mpu_message1_elements{i}{3} ~= 0
            in_data_col = in_data_col + 1;
        end
        in_data_col = in_data_col + array_size;
        continue;
    end
    
    % 根据 sigSize 标志进行条件处理
    if mpu_message1_elements{i}{3} == 0 % 无 sigSize
        % 填充时间
        eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.time(row_begin:row_begin + row_num - 1, :) = in_data(:, 1);']);
        % 填充值
        if array_size == 1
            eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.signals.values(row_begin:row_begin + row_num - 1, :) = cast(in_data(1:row_num,in_data_col), ', '''mpu_message1_elements{i}{6}''', ');']);
        else
            eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.signals.values(row_begin:row_begin + row_num - 1, 1:array_size) = cast(in_data(1:row_num, in_data_col:in_data_col+array_size-1), ', '''mpu_message1_elements{i}{6}''', ');']);
        end
        eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.signals.dimensions = array_size;']);
        in_data_col = in_data_col + array_size;
    else % 有 sigSize
        % 填充 sigSize 时间和值
        eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.sigSize.time(row_begin:row_begin + row_num - 1, :) = in_data(:, 1);']);
        eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.sigSize.signals.values(row_begin:row_begin + row_num - 1, :) = cast(in_data(1:row_num,in_data_col), ', '''mpu_message1_elements{i}{5}''', ');']);
        in_data_col = in_data_col + 1;
        eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.sigSize.signals.dimensions = 1;']);
        
        % 填充 sigValue 时间和值
        eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.sigValue.time(row_begin:row_begin + row_num - 1, :) = in_data(:, 1);']);
        eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.sigValue.signals.values(row_begin:row_begin + row_num - 1, 1:array_size) = cast(in_data(1:row_num, in_data_col:in_data_col+array_size-1), ', '''mpu_message1_elements{i}{6}''', ');']);
        eval(['MpuMessage1.', mpu_message1_elements{i}{1}, '.sigValue.signals.dimensions = array_size;']);
        in_data_col = in_data_col + array_size;
    end
end

% 4. 清理
clear_vars={'array_size','buff_size','i','in_data_col'};
clear(clear_vars{:});

# 大体解析模块详细设计

## 2.1 runAnalysis.m
#### 2.1.1 模块说明
`runAnalysis.m` 脚本是通用分析的主要入口点，可能侧重于比较和汇总来自各种仿真和数据源的问题点。它读取 Excel 文件中的问题列表，提取相关信息，执行比较，然后生成包含嵌入图像和详细数据的高度格式化的 Excel 报告。

#### 2.1.2 重点逻辑
1.  **初始化和路径设置：** 清除 `keys`，定义 `latestResimSoftVer`、`realResimSoftVer`、`chkFlgName` 和 `mf4_file_list` 路径。初始化 `only_dic` 和 `resim_dic`。
2.  **加载和处理最新重仿真问题列表：** 查找 `*_Resim*.xlsx` 文件，读取内容，提取问题信息，并填充 `NameListLatestResim` 和 `resim_dic`。
3.  **加载和处理真实重仿真问题列表（已注释掉）：** 类似地处理 `*RealResim*.xlsx` 文件，但此功能当前被禁用。
4.  **加载和处理 OnlyMF4 问题列表：** 查找 `*Only*.xlsx` 文件，读取内容，提取问题信息，填充 `NameListOnlyMF4` 和 `only_dic`。调用 `findResimTime.m` 查找重仿真时间。
5.  **数据准备和排序：** 将 `NameListOnlyMF4` 合并为唯一列表，并进行排序。
6.  **Excel 报告生成（主循环）：** 遍历排序后的 `NameListOnlyMF4`。
    *   **Excel COM 自动化：** 打开 Excel，创建新工作簿或添加新工作表。
    *   **临时图形路径：** 创建 `tmpFig` 目录。
    *   **网络摄像头图像嵌入：** 调用 `matchAviFile` 查找 AVI 文件，调用 `PlotFrontCam` 生成图像，并嵌入到 Excel 中。
    *   **ParaPara 文件嵌入：** 定位并嵌入由 `createOnlyMF4Parapara.m` 生成的 ParaPara 图像。
    *   **LM/MPU BEV 嵌入（条件性）：** 如果问题类型为“724_CenterLineOfForwardMapIsBroken”，则调用 `GenerateResimPara` 和 `PlotMpuLine` 生成并嵌入 LM BEV 和 MPU BEV 图像。
    *   **重仿真 ParaPara 嵌入：** 查找并嵌入“最新重仿真”和“真实重仿真”ParaPara 文件。如果未找到，可能即时生成。
    *   **Excel 表格格式化和内容填充：** 填充详细表格，应用格式，设置工作表名称，添加 Google 地图超链接，并更新“重新出现”状态。
    *   **保存并退出 Excel：** 保存工作簿并退出 Excel。
    *   **清理：** 删除 `tmpFig` 目录。

#### 2.1.3 模块内部交互
`runAnalysis.m` 脚本通过 `actxserver` 与 Excel 应用程序进行 COM 自动化交互，并调用以下外部 MATLAB 脚本或函数：
*   `findResimTime.m`：查找重仿真时间。
*   `PlotFrontCam.m`：绘制前置摄像头图像。
*   `matchAviFile.m`：匹配 AVI 视频文件。
*   `GenerateResimPara.m`：生成重仿真 ParaPara。
*   `PlotMpuLine.m`：绘制 MPU 车道/边界。
*   `getResimTimeByTypeAndOnlyTime.m`：查找重仿真时间。

#### 2.1.4 关键伪代码

matlab
% runAnalysis.m - 通用分析主脚本

clear keys
latestResimSoftVer = strcat('Gen3_',soft_ver);
realResimSoftVer = '-';
chkFlgName = ["724","723","711","710","731","732","725","728","726","727"];
mf4_file_list = fullfile(currentDir,'data','mf4_info','mf4_file_list.mat');

% 1. 加载和处理最新重仿真问题列表
resimBIssueListDir = dir(fullfile(currentDir,'data','IssueList','B','*_Resim*'));
for i = 1:length(resimBIssueListDir)
    % ... 读取 Excel，提取数据，填充 NameListLatestResim 和 resim_dic ...
end

% 2. 加载和处理 OnlyMF4 问题列表
OnlyBIssueListDir = dir(fullfile(currentDir,'data','IssueList','B','*Only*'));
for i = 1:length(OnlyBIssueListDir)
    % ... 读取 Excel，提取数据，填充 NameListOnlyMF4 和 only_dic ...
    get_resim_time_dic = findResimTime(only_dic, resim_dic); % 查找重仿真时间

    % ... 数据准备和排序 ...

    for j = 2:length(NameListOnlyMF4)
        % 3. Excel 报告生成（主循环）
        Excel = actxserver('Excel.Application');
        % ... 创建工作簿/工作表 ...

        % 网络摄像头图像嵌入
        [aviMatchName, aviMatchResult] = matchAviFile(aviDir,point,onlyName); % 匹配 AVI 文件
        fig1 = PlotFrontCam(videoPoint1,NameListOnlyMF4(j).type,aviPath); % 绘制前置摄像头图像
        % ... 保存图像并嵌入 ...

        % ParaPara 文件嵌入
        % ... 定位并嵌入 ParaPara 图像 ...

        % LM/MPU BEV 嵌入（条件性）
        if NameListOnlyMF4(j).type == "724_CenterLineOfForwardMapIsBroken"
            GenerateResimPara(currentDir,NameListOnlyMF4(j),reapperType); % 生成重仿真 ParaPara
            PlotMpuLine(point,folPath); % 绘制 MPU 车道/边界
            % ... 嵌入图像 ...
        end

        % 重仿真 ParaPara 嵌入
        % ... 查找并嵌入重仿真 ParaPara ...

        % Excel 表格格式化和内容填充
        % ... 填充表格，应用格式，设置名称，添加链接，更新状态 ...

        Workbook.SaveAs(fullfile(excelPath,date,excelName)); 
        Excel.Quit;
        Excel.delete;
    end
end

% 清理
rmdir(tmpFigPath,'s');


---

## 2.2 findResimTime.m
#### 2.2.1 模块说明
`findResimTime.m` 函数旨在为给定的一组“only”（原始）时间点查找相应的“resim”（重仿真）时间点。它接收两个 `containers.Map` 对象（`onlyTimeDic` 和 `resimTimeDic`），其中键可能是问题类型，值是时间点数组。然后，它尝试在小容差（1 秒）内将每个“only”时间点与最接近的“resim”时间点进行匹配。

#### 2.2.2 重点逻辑
1.  **函数签名：** 接收 `onlyTimeDic` 和 `resimTimeDic`（`containers.Map` 对象）。
2.  **遍历 `onlyTimeDic`：** 遍历 `onlyTimeDic` 中的每个键值对。
3.  **匹配 `only_value` 与 `resimTimeDic`：**
    *   如果 `only_key` 不存在于 `resimTimeDic` 中或 `resimTimeDic` 为空，则 `new_value` 填充 `NaN`。
    *   否则，调用嵌套函数 `find_matches` 执行实际匹配。
4.  **填充 `resim_time_dic`：** 将匹配的重仿真时间存储在 `resim_time_dic` 中。
5.  **`find_matches` 嵌套函数：** 初始化 `matches` 和 `used`。对 `onlyTime` 进行排序。遍历 `onlyTime`，在 `resimTime` 中查找最接近且未使用的匹配项（容差小于 1 秒）。如果找到匹配项，则存储匹配对并标记 `resimTime` 为已使用。如果未找到，则存储 `NaN`。打印匹配结果。
6.  **`strip_trailing_zeros` 嵌套函数：** 辅助函数，用于从数字字符串中删除尾随零和小数点。

#### 2.2.3 模块内部交互
`findResimTime.m` 脚本主要使用 `containers.Map` 和基本的 MATLAB 数组操作。

#### 2.2.4 关键伪代码

matlab
% findResimTime.m - 查找重仿真时间

function resim_time_dic = findResimTime(onlyTimeDic, resimTimeDic)
    all_only_keys = keys(onlyTimeDic);
    all_only_values = values(onlyTimeDic);

    resim_time_dic = containers.Map();
    
    for i = 1:length(all_only_keys)
        only_key = all_only_keys{i};
        only_value = all_only_values{i};

        new_value = [];
        if isempty(resimTimeDic)||~ismember(only_key, keys(resimTimeDic))
            for j = 1:length(only_value)
                new_value(end+1)=NaN;
            end
        else
            matches = find_matches(only_value, resimTimeDic(only_key));

            [numRows, numCols] = size(matches);
            for j = 1:numRows
                match_time = matches{j,2};
                new_value(end+1)=match_time{1};
            end
        end
        resim_time_dic(only_key) = new_value;

    end
end

function matches = find_matches(onlyTime, resimTime)
    matches = cell(length(onlyTime), 2); 
    used = false(1, length(resimTime));   
    [A_sorted, original_indices] = sort(onlyTime);

    for i = 1:length(A_sorted)
        a = A_sorted(i);
        best_diff = inf;         
        best_index = -1;         
        
        for j = 1:length(resimTime)
            if ~used(j) 
                diff = abs(a - resimTime(j));
                if diff < 1 && diff < best_diff
                    best_diff = diff;
                    best_index = j;
                end
            end
        end
        
        if best_index ~= -1
            matches{original_indices(i), 1} = onlyTime(original_indices(i));
            matches{original_indices(i), 2} = resimTime(best_index);
            used(best_index) = true;
        else
            matches{original_indices(i), 1} = onlyTime(original_indices(i));
            matches{original_indices(i), 2} = NaN;
        end
    end
end

function str = strip_trailing_zeros(num_str)
    if contains(num_str, '.') && ~contains(num_str, 'e')
        str = regexprep(num_str, '\.?0+$', '');
    else
        str = num_str;
    end
end


---

## 2.3 PlotFrontCam.m
#### 2.3.1 模块说明
`PlotFrontCam.m` 函数从给定视频文件（`.avi`）中提取指定时间点的特定帧，并在 MATLAB 图形中显示。它旨在可视化特定时刻的前置摄像头视图，为分析提供视觉上下文。

#### 2.3.2 重点逻辑
1.  **函数签名：** 接收 `pointTime`（时间点）、`PLDType`（PLD 类型）和 `videoPath`（视频文件路径）。
2.  **视频加载和时间设置：** 使用 `VideoReader` 加载视频，获取持续时间。将 `pointTime` 四舍五入，并设置 `v.currenttime`。如果 `pointTime` 超出视频范围，则调整 `v.currenttime` 并发出警告。
3.  **帧读取和显示：** 读取视频帧，创建新的 MATLAB 图形（最初不可见），创建子图，并在子图中显示视频帧。
4.  **绘图格式：** 移除 X 和 Y 轴刻度，设置标题（包含视频文件名、PLD 类型和时间），设置字体大小。

#### 2.3.3 模块内部交互
`PlotFrontCam.m` 函数主要使用内置的 `VideoReader` 类。

#### 2.3.4 关键伪代码

matlab
% PlotFrontCam.m - 绘制前置摄像头图像

function fig = PlotFrontCam(pointTime,PLDType,videoPath)
    v = VideoReader(videoPath);
    videotime = v.Duration;
    [~,chkMovieFileName,~] = fileparts(videoPath);
    fig = figure('Visible',0);
    ax1 = subplot('Position',[.1 .15 .8 .8]);
    fig.Position = [0 0 1366 768];
    
    movieSetTime = round(pointTime,2);
    if movieSetTime<videotime
        v.currenttime = movieSetTime;
    else
        v.currenttime = videotime - 0.1;
        warning(string(movieSetTime));
        warning(videoPath);
    end
    vidFrame = readFrame(v);
    image(ax1,vidFrame);
    set(ax1,'xtick',[],'ytick',[]);
    hold on;
    nowtime = strcat(strrep(chkMovieFileName,'_','\_'),...
                     ', ChkFlgName = ',strrep(PLDType,'_','\_'), ...
                     ', Time = ',num2str(pointTime));
    title(ax1,nowtime);
    set(ax1,'FontSize',22,'Visible',1);
    ax1.TitleFontSizeMultiplier = 1;
end


---

## 2.4 GenerateResimPara.m
#### 2.4.1 模块说明
`GenerateResimPara.m` 函数为 Resim（重仿真）数据生成“ParaPara”图（可能是 BEV 或类似图）。它接收一个问题点，加载相应的 Resim 数据，围绕该点生成图，并将其保存为 PNG 图像到临时目录 (`tmpFig`) 中。它支持为“最新”和“真实”Resim 类型生成图。

#### 2.4.2 重点逻辑
1.  **函数签名：** 接收 `currentDir`、`NameListOnlyMF4`（问题点信息结构体）和 `reapperType`（Resim 类型）。
2.  **数据路径确定：** 根据 `reapperType` 确定 `dataFolder`。从 `NameListOnlyMF4.point` 中提取 `point`，并在 `time1` 中找到最接近的索引。
3.  **Resim 数据识别：** 根据 `sw_DataType` 和 `dataFolder` 识别 `simResNames`。从 `simResNames` 中提取 `simResName`、`folderName`、`dirName`。
4.  **绘图设置：** 将 `subFunc` 添加到 MATLAB 路径。调用 `PlotLmLine.m` 加载 Resim 数据并生成初始 LM 图。
5.  **“724_CenterLineOfForwardMapIsBroken”问题类型的特殊处理：** 如果问题类型匹配，则暂时禁用相机 C0 轨迹绘图，更新绘图，保存 `figLmLine` 为 `LMMapPic.png`，然后重新启用相机 C0 轨迹绘图。
6.  **“ParaPara”图生成循环：** 定义两个时间点围绕问题点。遍历这些点。
    *   创建新图形，设置子图布局。
    *   调用 `SelectPlot2.m` 绘制各种信号。
    *   设置绘图格式，添加注释。
    *   调用 `SetTimePlot_r06.m` 生成时域图。
    *   调用 `RankBTimePlot.m` 生成 Rank B 信号图。
    *   保存图形为 PNG 图像到 `tmpFig`。
    *   关闭图形。
7.  **清理：** 从 MATLAB 路径中删除 `subFunc`，关闭所有图形。

#### 2.4.3 模块内部交互
`GenerateResimPara.m` 脚本调用以下外部 MATLAB 脚本或函数：
*   `PlotLmLine.m`：生成 LM 绘图。
*   `RePlotLmLine.m`：重新绘制 LM 绘图。
*   `SelectPlot2.m`：绘制各种信号。
*   `SetTimePlot_r06.m`：生成时域图。
*   `RankBTimePlot.m`：生成 Rank B 信号图。

#### 2.4.4 关键伪代码

matlab
% GenerateResimPara.m - 生成重仿真 ParaPara

function GenerateResimPara(currentDir,NameListOnlyMF4,reapperType)
    sw_DataType = evalin('base', 'sw_DataType');
    time1 = evalin('base', 'curSignalTime');

    if reapperType == "latest"
        dataFolder = fullfile(currentDir,'data','matdata',NameListOnlyMF4.name);
    elseif reapperType == "real"
        dataFolder = fullfile(currentDir,'data','realMatdata',NameListOnlyMF4.name);
    end
    point = double(strrep(strrep(strrep(NameListOnlyMF4.point,'time_',''),'[sec]',''),'.png',''));
    [~, pointr] = min(abs(point - time1));
    point = ceil(pointr);

    % ... Resim 数据识别 ...

    addpath(genpath('subFunc'))
    PlotLmLine; % 加载 Resim 数据并生成初始 LM 图

    if NameListOnlyMF4.type == "724_CenterLineOfForwardMapIsBroken"
        chkbox_camC0Trace.Value = 0;
        timeEdit_obj.String=string(time1(point));
        RePlotLmLine( timeEdit_obj );
        saveas(figLmLine,fullfile(pwd,'tmpFig','LMMapPic.png'));
        chkbox_camC0Trace.Value = 1;
    end

    ZZ_pickUpIndex = [point-1;point];
    for pickUpIndexCnt=1:length(ZZ_pickUpIndex)
        l=ZZ_pickUpIndex(pickUpIndexCnt);
        figPara=figure('visible','off');clf;
        % ... 图形设置 ...
        ax99 = subplot(9,4,[1,2,5,6,9,10,13,14,17,18,21,22,25,26,29,30,33,34]);
        swDispCont = [6 4 5 7 8 9];
        chkbox_MapLane.Value = 1;
        SelectPlot2; % 绘制各种信号
        % ... 绘图格式设置 ...
        SetTimePlot_r06; % 生成时域图
        RankBTimePlot; % 生成 Rank B 信号图
        
        if reapperType == "latest"
            picName = strcat("latestPara_",string(pickUpIndexCnt-1),".png");
        elseif reapperType == "real"
            picName = strcat("realPara_",string(pickUpIndexCnt-1),".png");
        end  
        saveas(figPara, strcat(pwd,'\tmpFig\',picName));
        close(figPara);
    end
    rmpath(genpath('subFunc'))
    close all;
end


---

## 2.5 PlotMpuLine.m
#### 2.5.1 模块说明
`PlotMpuLine.m` 函数旨在可视化从 `MpuMessage1`（可能还有 `MpuMessage3`）数据中提取的各种车道和边界信息。它加载 MPU 数据，处理不同类型的车道属性（实线、虚线、其他），然后调用 `plotFig` 生成 MPU 派生车道和边界线的鸟瞰图 (BEV)。它还将生成的图形保存为 `MPUMapPic.png`。

#### 2.5.2 重点逻辑
1.  **函数签名：** 接收 `curPoint`（时间点）和 `folPath`（MAT 文件路径）。
2.  **加载 MPU 数据：** 定位并加载 `*MPU_message12*.mat` 文件中的所有变量。
3.  **提取和处理车道/边界数据：** 从 `MpuMessage1` 中提取大量信号，并根据属性（例如实线、虚线）进行处理和过滤。
4.  **加载 `MpuMessage3`（条件性）：** 如果 `MpuMessage3` 已加载，则提取 `ht_lat` 和 `ht_lon`。
5.  **绘图限制：** 设置绘图轴的 `xlimVLow`、`xlimVHigh`、`ylimVLow`、`ylimVHigh`。
6.  **绘图执行：** 调用 `plotFig.m` 生成 BEV 绘图。最大化图形窗口。设置 `slider_obj.Value`。调用 `ReplotBEV_fig6.m` 更新绘图。保存 `fig6` 为 `MPUMapPic.png`。

#### 2.5.3 模块内部交互
`PlotMpuLine.m` 脚本调用以下外部 MATLAB 脚本或函数：
*   `plotFig.m`：生成 BEV 绘图。
*   `ReplotBEV_fig6.m`：重新绘制 BEV 绘图。

#### 2.5.4 关键伪代码

matlab
% PlotMpuLine.m - 绘制 MPU 车道/边界

function PlotMpuLine(curPoint,folPath)
    mpuNameDir = dir(fullfile(folPath,'*MPU_message12*.mat'));
    mpuPath = fullfile(mpuNameDir.folder,mpuNameDir.name);
    load(mpuPath); % 加载 MPU 数据

    % ... 提取和处理车道/边界数据 ...

    if exist('MpuMessage3', 'var')
        ht_lat = MpuMessage3.htLatitude.signals.values;
        ht_lon = MpuMessage3.htLongitude.signals.values;
    end

    xlimVLow = -20; xlimVHigh = 20;
    ylimVLow = -350; ylimVHigh = 400;

    plotFig; % 生成 BEV 绘图
    frame_h = get(handle(gcf),'JavaFrame');
    set(frame_h,'Maximized',1);
    slider_obj.Value=double( find(abs(LogTime-curPoint)==min(abs(LogTime-curPoint))) );
    ReplotBEV_fig6; % 重新绘制 BEV 绘图

    saveas(fig6,fullfile(pwd,'tmpFig','MPUMapPic.png'));
end


---

## 2.6 getResimTimeByTypeAndOnlyTime.m
#### 2.6.1 模块说明
`getResimTimeByTypeAndOnlyTime.m` 函数充当查找实用程序。给定“only”（原始）数据中的问题类型 (`onlyType`) 和特定时间点 (`onlyTime`)，它从预先计算的字典 (`getResimTimeDic`) 中检索相应的“resim”（重仿真）时间点。

#### 2.6.2 重点逻辑
1.  **函数签名：** 接收 `onlyType`、`onlyTime`、`onlyDic` 和 `getResimTimeDic`。
2.  **检索时间数组：** 从 `onlyDic` 和 `getResimTimeDic` 中检索给定 `onlyType` 的“only”时间点数组和匹配的“resim”时间点数组。
3.  **查找循环：** 遍历“only”时间点数组。如果 `onlyTime` 匹配一个元素，则从匹配的“resim”时间点数组中检索相应的值，并中断循环。

#### 2.6.3 模块内部交互
`getResimTimeByTypeAndOnlyTime.m` 函数不调用其他脚本或函数，仅使用 `containers.Map` 进行字典查找。

#### 2.6.4 关键伪代码

matlab
% getResimTimeByTypeAndOnlyTime.m - 查找重仿真时间

function resim_time = getResimTimeByTypeAndOnlyTime(onlyType,onlyTime,onlyDic, getResimTimeDic)
    resim_time = '';
    
    all_only_time = onlyDic(onlyType);
    all_get_resim_time = getResimTimeDic(onlyType);

    for i = 1:length(all_only_time)
        if onlyTime== all_only_time(i)
            resim_time = all_get_resim_time(i);
            break
        end
    end
end

# L01/L02 解析模块详细设计

## 2.1 main_new.m
#### 2.1.1 模块说明
`main_new.m` 是 L01/L02 分析报告生成的主入口点。它从各种来源（问题列表、转换后的 MAT 数据）读取数据，进行处理，然后填充并格式化 Excel 电子表格，其中包含分析结果、Google 地图链接和嵌入式图像。

#### 2.1.2 重点逻辑
1.  **初始化与路径设置：** 记录开始时间，将 `Scripts` 子目录添加到 MATLAB 路径，并定义数据文件夹和问题列表路径。定位并可能重命名 L01/L02 Excel 模板文件。
2.  **Excel COM 自动化（初始数据填充）：** 使用 `actxserver` 打开 Excel，从问题列表文件读取数据，解析问题时间 (`time_(\d+\.?\d*)`) 和 `PLDStatus`，并填充主 Excel 工作表中的特定单元格。加载 `mf4_file_list.mat` 以匹配 MF4 文件名。
3.  **`createExcelSheet;`：** 调用外部脚本 `createExcelSheet.m`，负责创建或初始化 Excel 工作表结构。
4.  **Excel 数据处理（在 `createExcelSheet` 之后）：** 读取 Excel 内容，提取数据名称和问题时间点，并调用 `addSign_V20;` 添加签名或额外信息。
5.  **数据分组和迭代：** 使用 `containers.Map` 按数据名称对数据进行分组，以便按数据文件处理所有相关问题点。
6.  **每个数据名称的处理循环：**
    *   **数据加载：** 定位数据文件夹并加载相关的 MAT 文件（例如 `*MPU_message12.mat`）。
    *   **`writeLinkID` 调用：** 调用 `writeLinkID` 将链接 ID 写入 Excel 文件。
    *   **`GoogleMapLinks;`：** 调用 `GoogleMapLinks.m` 生成 Google 地图链接。
    *   **`main2;`：** 调用 `main2.m` 进行绘图和进一步分析。
    *   **每个问题点的处理循环：**
        *   **AVI 文件匹配：** 调用 `matchAviFile` 查找与当前时间点对应的 AVI 文件。
        *   **图像生成：** 调用 `plotPointFrameOfAvi` 生成网络摄像头图片并保存到临时路径。
        *   **Excel 更新：** 更新 Excel 单元格，如果未找到 AVI 则标记“No WebCam”。
7.  **最终 Excel 格式化和图像嵌入：** 保存 `excRaw` 数据回 Excel，添加超链接，应用广泛的格式（行高、边框、列宽、对齐、字体），并调用 `savePicsToExc_V20` 将生成的图片嵌入到 Excel 工作表中。
8.  **性能测量和清理：** 记录总耗时，并从 MATLAB 路径中删除 `Scripts`。

#### 2.1.3 模块内部交互
`main_new.m` 脚本通过 `actxserver` 与 Excel 应用程序进行 COM 自动化交互，并调用以下外部 MATLAB 脚本或函数：
*   `createExcelSheet.m`：创建和初始化 Excel 工作表。
*   `addSign_V20.m`：对 Excel 工作表应用格式。
*   `writeLinkID.m`：从 MPU 数据中提取链接 ID 并写入 Excel。
*   `GoogleMapLinks.m`：生成 Google 地图链接。
*   `main2.m`：进行绘图和进一步分析。
*   `matchAviFile.m`：匹配 AVI 视频文件。
*   `plotPointFrameOfAvi.m`：从 AVI 文件中提取帧并保存为图片。
*   `savePicsToExc_V20.m`：将图片嵌入到 Excel 工作表中。

#### 2.1.4 关键伪代码

matlab
% main_new.m - L01/L02 分析报告生成主脚本

L01L02StartTime = clock;
addpath(fullfile(pwd,'Scripts'));

% 1. 初始化和路径设置
dataFolder = fullfile(currentDir,'data','matdata');
issueListB=fullfile(currentDir,'\data\issueList\B');
excPath = fullfile(excDir.folder,excDir.name);

% 2. Excel COM 自动化 (初始数据填充)
Excel = actxserver('Excel.Application');
Workbooks = Excel.Workbooks;
Workbook = Workbooks.Open(excPath);
Sheets = Excel.ActiveWorkBook.Sheets;
Sheet = get(Sheets,'Item',1);

% 读取问题列表并填充 Excel
for i = 3:length(issueListBDir)
    % ... 解析问题数据，提取 dataNameAll, issueTime, PLDStatus ...
    % ... 加载 mf4_file_list.mat 匹配 mf4_file_name ...
    Sheet.Range(strcat('D',lines)).value = dataNameAll;
    Sheet.Range(strcat('E',lines)).value = issueTime;
    Sheet.Range(strcat('F',lines)).value = mf4_file_name;
    Sheet.Range(strcat('H',lines)).value = "728_UnableToEstimateEgoLane";
end
Workbook.SaveAs(excPath);
Excel.Quit;
Excel.delete;

% 3. createExcelSheet;
createExcelSheet;

% 4. Excel 数据处理 (在 createExcelSheet 之后)
[~,~,excRaw]=xlsread(excPath);
dataNameColu=string(excRaw(:,4));
pointColu=string(excRaw(:,5));
dataNameArr = horzcat(dataNameColu,pointColu);
addSign_V20; % 添加签名或额外信息

% 5. 数据分组和迭代
dataFolderArr = containers.Map('KeyType', 'char', 'ValueType', 'any');
for i = 1:size(dataNameArr, 1)
    % ... 数据分组逻辑 ...
end

keys = cellstr(unique(dataNameArr(:, 1), 'stable'));
for i = 1:length(keys)
    key = keys{i};
    timeValues = dataFolderArr(key);
    
    % 6. 每个数据名称的处理循环
    trueDataNameAll=key;
    folPath = fullfile(dataFolder,trueDataNameAll);
    MPUDir = dir(fullfile(folPath,'*MPU_message12.mat'));
    
    excRaw = writeLinkID(excRaw,folPath,trueDataName,curPointStingArr); % 写入链接 ID
    GoogleMapLinks; % 生成 Google 地图链接
    main2; % 绘图和进一步分析

    % 每个问题点的处理循环
    for j=1:length(dataTimeArr)
        curPoint=round(double(dataTimeArr(j)),1);
        % ... AVI 文件匹配 ...
        [aviMatchName, aviMatchResult] = matchAviFile(AviFiles,newPoint,simResName);
        plotPointFrameOfAvi(newPoint,curPoint2,folPath,trueDataName,curAviNAME,curAviNAME1,savePicPath); % 生成网络摄像头图片
        % ... Excel 更新 ...
    end
end

% 7. 最终 Excel 格式化和图像嵌入
result = xlswrite(excPath,excRaw);
if hyperlinkAll ~= ""
    Excel = actxserver('Excel.Application');
    Workbooks = Excel.Workbook;
    Workbook = Workbooks.Open(excPath);
    Sheets = Workbook.Sheets;
    % ... 添加超链接，设置格式 (行高、边框、列宽、对齐、字体) ...
    savePicsToExc_V20(Sheets,excPath,trueDataName,rawCurpoint,savePicPath); % 嵌入图片
    Workbook.Save;
    Excel.Quit;
    Excel.delete;
end

% 8. 性能测量和清理
L01L02EndTime = clock;
elapsed_time = etime(L01L02EndTime, L01L02StartTime);
fprintf('L01L02 total waste time: %.1f[s]\n', elapsed_time);
rmpath(fullfile(pwd,'Scripts'));


---

## 2.2 createExcelSheet.m
#### 2.2.1 模块说明
`createExcelSheet.m` 脚本负责根据主工作表（"Sheet1"）中发现的唯一数据名称和问题时间，动态地在 L01/L02 Excel 报告中创建新的工作表。它还会在主工作表和这些新创建的工作表之间添加超链接，以方便导航。

#### 2.2.2 重点逻辑
1.  **Excel 应用程序设置：** 接收 `excPath`，使用 `actxserver` 打开 Excel 应用程序和工作簿，并将其设置为后台运行。
2.  **从 "Sheet1" 读取数据：** 激活 "Sheet1"，从 "D" 和 "E" 列读取数据（包含数据名称和问题时间），并进行清理。
3.  **生成工作表名称：** 遍历读取的数据，根据数据名称和问题时间生成唯一的 `SheetName`。
4.  **动态工作表创建和超链接：** 遍历生成的 `SheetName` 列表，如果工作表不存在且有效，则创建新工作表并重命名。在主工作表和新工作表之间添加双向超链接，并为主工作表中的链接单元格添加边框。
5.  **保存并退出 Excel：** 保存 Excel 工作簿，退出 Excel 应用程序，并删除 Excel 对象。

#### 2.2.3 模块内部交互
`createExcelSheet.m` 脚本主要通过 `actxserver` 与 Excel 应用程序进行 COM 自动化交互。

#### 2.2.4 关键伪代码

matlab
% createExcelSheet.m - Excel 工作表创建脚本

ExcelFilePath=excPath;
Excel = actxserver('Excel.Application');
Workbooks = Excel.Workbook;
exlFile = Workbooks.Open(ExcelFilePath);
set(Excel,'Visible',0);
Sheets = Excel.ActiveWorkBook.Sheets;

% 1. 从 "Sheet1" 读取数据
Sheet1 = get(Sheets,'Item','Sheet1');
Sheet1.Activate;
data = Sheet1.Range("D:E").value;
data = string(data(3:end,1:2));
data = rmmissing(data);

% 2. 生成工作表名称
for i = 1:length(data(:,1))
    temp = char(data(i,1));
    if temp ~='-'
        SheetName(i,1) = strcat(temp(1:15),'_',data(i,2));
    else
        SheetName(i,1) ="-";
    end
end

% 3. 动态工作表创建和超链接
j = 3;
if exist('SheetName', 'var')
    for i = 1:length(SheetName)
        if contains(SheetName(i,1),sheetNames)
            % do nothing
        else
            if SheetName(i,1)~='-'
                exlFile.WorkSheet.Add([],exlFile.WorkSheets.Item(exlFile.WorkSheets.Count));
                exlFile.WorkSheets.Item(exlFile.WorkSheets.Count).Name = SheetName(i,1);
                Sheet = get(Sheets,'Item',SheetName(i,1));
                Sheet.Activate;
                obj = Sheet.Range('B1');
                obj.Hyperlinks.Add(obj,excelfile,strcat('Sheet1!','C',string(j)),[],'Return'); % 从新工作表链接回 Sheet1
                obj1 = Sheet1.Range(strcat("C",string(j)));
                obj1.Hyperlinks.Add(obj1,excelfile,strcat(SheetName(i,1),'!$A$1'),[],'check'); % 从 Sheet1 链接到新工作表
                obj1.Borders(1).LineStyle = 1;
                obj1.Borders(1).Weight = 2;
                obj1.Borders(1).ColorIndex = 1;
                j = j+1;
            else
                 j = j+1;
            end
        end
    end
end

% 4. 保存并退出 Excel
exlFile.Save;
Excel.Quit;
Excel.delete;


---

## 2.3 addSign_V20.m
#### 2.3.1 模块说明
`addSign_V20.m` 脚本主要负责对 L01/L02 Excel 报告中动态创建的工作表应用广泛的格式。它合并单元格，设置背景颜色、字体样式、大小和对齐方式，有效地在每个分析工作表上创建预定义的区域或“签名”。

#### 2.3.2 重点逻辑
1.  **Excel 应用程序设置：** 接收 `excPath`，使用 `actxserver` 打开 Excel 应用程序和工作簿，并将其设置为后台运行。
2.  **遍历工作表：** 获取工作簿中的所有工作表名称，并遍历每个工作表。它仅对不是“Sheet1”且不是“QƐ_⑫”的工作表应用格式。
3.  **对特定范围应用格式：** 在每个相关工作表的循环中，它对预定义的单元格范围应用一系列格式操作，包括合并单元格、设置背景颜色、字体属性（大小、名称、粗体）和文本对齐方式。这为后续的数据和图像插入创建了结构化的区域。
4.  **保存并退出 Excel：** 保存 Excel 工作簿，退出 Excel 应用程序，并删除 Excel 对象。

#### 2.3.3 模块内部交互
`addSign_V20.m` 脚本主要通过 `actxserver` 与 Excel 应用程序进行 COM 自动化交互。

#### 2.3.4 关键伪代码

matlab
% addSign_V20.m - Excel 工作表格式化脚本

ExcelFilePath = excPath;
Excel = actxserver('Excel.Application');
Workbooks = Excel.Workbook;
exlFile = Workbooks.Open(ExcelFilePath);
set(Excel,'Visible',0);
Sheets = Excel.ActiveWorkBook.Sheets;
sheetNum = sheetnames(ExcelFilePath);

% 1. 遍历工作表并应用格式
for i = 1:length(sheetNum)
    sheet_name = sheetNum(i,1);
    Sheet1 = get(Sheets,'Item',sheet_name);
    if sheet_name ~= "Sheet1" && sheet_name ~= "QƐ_⑫"
        % 应用各种格式，例如合并单元格、设置颜色、字体等
        Range = Sheet1.Range( strcat('A',string(2),':','AO',string(2+2)) );
        Range.Merge();
        Range.Interior.Color = int32(hex2dec('b8b644'));
        Range.Value='MF4';
        Range.Font.Size = 14;
        % ... 其他格式设置 ...
    end
end

% 2. 保存并退出 Excel
exlFile.Save;
Excel.Quit;
Excel.delete;


---

## 2.4 writeLinkID.m
#### 2.4.1 模块说明
`writeLinkID.m` 函数旨在从 `MpuMessage1` 数据（特别是 `mpuReserveUint`）中提取“链接 ID”，并将其写入 L01/L02 Excel 报告 (`excRaw`)。它将 Excel 工作表中的问题点与 MPU 数据中相应的时间条目进行匹配，以查找相关的链接 ID。

#### 2.4.2 重点逻辑
1.  **加载 MPU 数据：** 在 `folPath` 中定位 `*MPU_message12*.mat` 文件，并从中加载 `MpuMessage1`。提取 `MpuMessage1.mpuReserveUint.time` 作为时间基准。
2.  **遍历 Excel 行：** 从第三行开始遍历 `excRaw` 的行。对于每一行，提取 `dataName`（第 4 列）和 `excelCurpoint`（第 5 列）。
3.  **匹配数据名称和时间点：** 检查 Excel 中的 `dataName` 是否与 `trueDataName` 匹配，`excelCurpoint` 是否存在于 `curPointArr` 中，并且 Excel 行的第一列是否为空或缺失（表示链接 ID 尚未写入）。
4.  **在 MPU 数据中搜索链接 ID：** 如果找到匹配项，它会在 `MpuMessage1.mpuReserveUint.time` 数组中搜索包含 `justPoint1`（来自 Excel 的问题时间）的时间间隔。找到间隔后，提取 `MpuMessage1.mpuTimeStamp1.signals.values` 和 `MpuMessage1.mpuReserveUint.signals.values` 中的 `targetLinkID`。
5.  **将链接 ID 写入 Excel：** 将找到的 `linkID` 写入当前 Excel 行的第一列 (`excRaw(pp,1)`)。

#### 2.4.3 模块内部交互
`writeLinkID.m` 函数直接操作从 `.mat` 文件加载的 `MpuMessage1` 数据，并修改传入的 `excRaw` 单元格数组。

#### 2.4.4 关键伪代码

matlab
% writeLinkID.m - 写入链接 ID 到 Excel

function excRaw = writeLinkID(excRaw,folPath,trueDataName,curPointArr)
    MpumessagefileDir = dir(strcat(folPath,'\*MPU_message12*.mat'));
    MpumessagefilePath = fullfile(MpumessagefileDir.folder,MpumessagefileDir.name);
    load(MpumessagefilePath,'MpuMessage1');
    time = MpuMessage1.mpuReserveUint.time;
    
    for pp = 3:length(excRaw(:,4))
        justPoint1 = double(string(excRaw(pp,5)));
        dataName = string(char(string(excRaw(pp,4))));
        dataName = string(dataName(1:15));
        excelCurpoint = round(double(string(excRaw(pp,5))),1);
        
        if dataName == string(trueDataName) && (ismissing(string(excRaw(pp,1))) || string(excRaw(pp,1))=="") && ismember(string(excelCurpoint), curPointArr)
            % 搜索链接 ID
            targetLinkID = 0;
            for i = 2:length(time)
                if time(i-1) <= justPoint1 && justPoint1 <= time(i)
                    targetLinkID = MpuMessage1.mpuReserveUint.signals.values(i,3);
                    break;
                end
            end
            excRaw(pp,1) = {linkID}; % 写入链接 ID
        end
    end
end


---

## 2.5 GoogleMapLinks.m
#### 2.5.1 模块说明
`GoogleMapLinks.m` 脚本根据从 `MpuMessage3` 数据中提取的地理坐标（经度和纬度）生成 Google 地图超链接。这些超链接存储在 `hyperlinkAll` 变量中，随后由 `main_new.m` 用于嵌入到 Excel 报告中。

#### 2.5.2 重点逻辑
1.  **加载 MPU 数据：** 从 `MPUFile`（包含 `*MPU_message12*.mat`）加载 `MpuMessage3`。提取 `MpuMessage3.elapsedTime.time` 作为时间基准。
2.  **遍历问题点：** 遍历 `rawCurpointArr`（包含问题时间点）。
3.  **查找最近的时间点：** 对于每个 `rawCurpoint`，在 `SfuncTime` 中查找最接近的时间点索引。
4.  **提取坐标：** 从 `MpuMessage3.htLongitude.signals.values` 和 `MpuMessage3.htLatitude.signals.values` 中提取经纬度值。
5.  **生成 Google 地图超链接：** 使用提取的经纬度构建 Google 地图 URL (`https://maps.google.com/maps?q=<latitude> <longitude>`)。
6.  **累积超链接：** 将生成的超链接（以及经纬度字符串）累积到 `hyperlinkAll` 变量中。
7.  **清理：** 清除局部变量，保留调用前存在的变量。

#### 2.5.3 模块内部交互
`GoogleMapLinks.m` 脚本直接操作从 `.mat` 文件加载的 `MpuMessage3` 数据，并修改全局变量 `hyperlinkAll`。

#### 2.5.4 关键伪代码

matlab
% GoogleMapLinks.m - 生成 Google 地图链接

vars_goolgemap = who;
load(MPUFile,'MpuMessage3');
SfuncTime = MpuMessage3.elapsedTime.time;

for ri = 1:length(rawCurpointArr)
    rawCurpoint = double(rawCurpointArr(ri));
    [~, oi] = min(abs(SfuncTime - rawCurpoint)); % 查找最近的时间点
    
    longitude = MpuMessage3.htLongitude.signals.values;
    latitude = MpuMessage3.htLatitude.signals.values;
    
    hyperlink = strcat("https://maps.google.com/maps?q=",num2str(latitude(oi),'%.20g')," ",num2str(longitude(oi),'%.20g'));
    
    if hyperlinkAll == ""
        hyperlinkAll = [horzcat(num2str(latitude(oi),'%.20g'),num2str(longitude(oi),'%.20g'),hyperlink)];
    else
        hyperlinkAll = vertcat(hyperlinkAll,[horzcat(num2str(latitude(oi),'%.20g'),num2str(longitude(oi),'%.20g'),hyperlink)]);
    end
end

cmd = 'clearvars -except ';
cmd = [cmd, strjoin(vars_goolgemap, ' ')];
eval(cmd);


---

## 2.6 main2.m
#### 2.6.1 模块说明
`main2.m` 脚本是 L01/L02 分析的关键部分，主要用于生成围绕识别出的问题点的车道模型 (LM) 数据的详细图表和图像。它使用预先存在的图形 (`figLmLine`)，并根据特定的时间点重新绘制数据，然后将这些图表保存为 PNG 图像。它还提取并更新 Excel 报告中的某些信息。

#### 2.6.2 重点逻辑
1.  **初始化：** 初始化 `curPoint2Arr`，保存当前工作空间变量。调用 `PlotLmLine;` 生成初始 LM 线图。
2.  **图形最大化：** 最大化当前图形窗口。
3.  **数据提取和处理：** 提取 `emapY` 和 `pld`（车道模型状态信号），以及 `Minus1` 和 `Minus2`（可能指示特定事件）。
4.  **每个问题点的绘图循环：**
    *   为每个问题点创建临时保存图片目录。
    *   查找 `time` 数组中与 `curPoint` 最接近的 `pointIndex`，并根据 `emapY` 进一步优化 `pointIndex` 以精确定位事件。
    *   更新 `excRaw`（Excel 数据）中与事件时间相关的信息。
    *   **`RePlotLmLine` 调用和图像保存：** 设置 `timeEdit_obj.String`，调用 `RePlotLmLine` 重新绘制 LM 线图，并将生成的图形保存为 `LmLineFig1.png` 和 `LmLineFig1_1.png`。根据 `Minus2` 和 `pointIndex` 计算 `curPoint2`，并再次调用 `RePlotLmLine` 和保存 `LmLineFig3.png`。
    *   累积 `curPoint2Arr` 和 `newPointArr`。
5.  **清理：** 关闭所有图形，清除局部变量。

#### 2.6.3 模块内部交互
`main2.m` 脚本调用以下外部 MATLAB 脚本或函数：
*   `PlotLmLine.m`：生成 LM 线图。
*   `RePlotLmLine.m`：重新绘制 LM 线图。

#### 2.6.4 关键伪代码

matlab
% main2.m - LM 数据绘图和分析脚本

curPoint2Arr = [];
vars_main = who;
PlotLmLine; % 生成初始 LM 线图
vars_main2 = who;

frame_h = get(handle(gcf),'JavaFrame');
set(frame_h,'Maximized',1); % 最大化图形窗口

% 数据提取和处理
emapY=bitget(S_lmInhStt.signals.values,3);
pld = bitget(S_lmPldStt.signals.values(:,1),21);
Minus1 = S_lmldVecLaneLocMinus1.signals.values(:,1);
Minus2 = find(Minus1 == -1);

% 每个问题点的绘图循环
for ci = 1:length(curPointArr)
    savePicPath = strcat('tempSavePic\',strcat(trueDataNameAll,'_',dataTimeArr(ci)));
    if ~exist(savePicPath, 'dir')
        mkdir(savePicPath);
    end

    curPoint = curPointArr(ci);
    [~, pointIndex] = min(abs(curPoint - time)); % 查找最近的时间点
    % ... 优化 pointIndex 逻辑 ...

    % Excel 更新
    excRaw(h+2,23) = cellstr(string(time(pointIndex-1)));
    excRaw(h+2,22) = cellstr("-");
    result = xlswrite(excPath,excRaw);
    
    % RePlotLmLine 调用和图像保存
    curPoint=double(string(time(pointIndex-1)));
    timeEdit_obj.String=string(curPoint);
    RePlotLmLine( timeEdit_obj );
    LmLineFig1 = figLmLine;
    saveas(LmLineFig1,strcat(savePicPath,'\LmLineFig1.png'));
    
    curPoint=double(string(time(pointIndex)));
    timeEdit_obj.String=string(curPoint);
    RePlotLmLine( timeEdit_obj );
    LmLineFig1_1 = figLmLine;
    saveas(LmLineFig1_1,strcat(savePicPath,'\LmLineFig1_1.png'));
    
    % ... 计算 curPoint2 ...
    timeEdit_obj.String=curPoint2;
    RePlotLmLine( timeEdit_obj );
    LmLineFig3 = figLmLine;
    saveas(LmLineFig3,strcat(savePicPath,'\LmLineFig3.png'));
    
    curPoint2Arr = [curPoint2Arr, curPoint2];
    newPointArr = [newPointArr, double(string(time(pointIndex-1)))];
end

% 清理
close all;
cmd = 'clearvars -except ';
cmd = [cmd, strjoin(vars_main2, ' ')];
eval(cmd);


---

## 2.7 PlotLmLine.m
#### 2.7.1 模块说明
`PlotLmLine.m` 脚本负责加载 LM 分析所需的数据，执行一些初始计算（如 C0 轨迹和精度验证），然后在 MATLAB 图形中生成主要的 LM 线图（可能是鸟瞰图或类似表示）。它还设置了各种绘图参数和 UI 元素。

#### 2.7.2 重点逻辑
1.  **配置设置：** 定义 `Setting` 结构体，包含数据输入目录。设置大量 `sw_` 变量（开关），控制数据加载、处理、绘图和显示。定义常量如 `tt`、`ts`、`X`、`veclWidth`、`veclLength`。
2.  **数据加载和预处理（条件性）：**
    *   **初始加载：** 如果 `rePlotFlag` 为 0 或不存在，则执行初始数据加载。如果 `swComp` 为 1，允许用户选择 MAT 文件进行比较。根据文件名判断 `swCANape`。如果 `swWebCam` 为 1，允许用户选择 AVI 文件。
    *   **`LoadData;`：** 调用 `LoadData.m` 加载原始数据。
    *   **`swGenAndSig;`：** 调用 `swGenAndSig.m` 进行数据生成或信号处理。
    *   **`SetData;`：** 调用 `SetData.m` 设置数据结构或变量。
    *   **`accuracyVerif;`：** 调用 `accuracyVerif.m` 计算 C0 轨迹和 LM 精度验证。
3.  **绘图配置：** 定义 `swDispContRt` 和 `swDispContRtLarge`，控制绘图窗口中显示的内容。添加 `subFunc` 目录到 MATLAB 路径。
4.  **绘图执行（条件性）：**
    *   如果 `swSN` 为 1，调用 `plotSN;`。
    *   如果 `rePlotFlag` 为 0 或不存在，则执行初始绘图：调用 `PlotAccuracyVerif;`，创建新图形 (`figLmLine`) 并最大化，调用 `figPlotCommon;` 设置通用绘图元素，设置初始 `xlim` 和 `ylim`，清除现有轴，调用 `figPlotPlcm;` 绘制主 LM 图。
    *   如果 `rePlotFlag` 为 1，则重新执行绘图逻辑。
5.  **信息显示：** 更新 `TimeInfoTextBox.String` 和 `gnssEdit_obj.String` 显示时间、地图、MPU 和 GNSS 信息。

#### 2.7.3 模块内部交互
`PlotLmLine.m` 脚本调用以下外部 MATLAB 脚本或函数：
*   `LoadData.m`：加载数据。
*   `swGenAndSig.m`：数据生成和信号处理。
*   `SetData.m`：设置数据结构。
*   `accuracyVerif.m`：计算 C0 轨迹和 LM 精度验证。
*   `PlotAccuracyVerif.m`：生成精度验证图。
*   `figPlotCommon.m`：设置通用绘图元素。
*   `figPlotPlcm.m`：绘制主 LM 图。
*   `plotSN.m` (条件性)：绘制 SN 图。
*   `SetCollumPlot.m` (条件性)：设置列图。

#### 2.7.4 关键伪代码

matlab
% PlotLmLine.m - LM 数据加载和绘图脚本

L01L02StartTime = clock;
addpath(fullfile(pwd,'Scripts'));

% 1. 配置设置
Setting = struct();
Setting.InputDir = 'C:\Users\Private\Soft\Module\LM\SIM\Gen3ReSim\Data\matdata\';
% ... 其他 sw_ 变量和常量设置 ...

% 2. 数据加载和预处理
if (exist( "rePlotFlag" ) == 0 || rePlotFlag == 0) && swLoad
    if swComp
        % ... uigetfile 选择 MAT 文件 ...
    end
    % ... 判断 swCANape ...
    if swWebCam
        % ... uigetfile 选择 AVI 文件 ...
    end
    LoadData; % 加载原始数据
    swGenAndSig; % 数据生成或信号处理
    SetData; % 设置数据结构
    accuracyVerif; % 计算 C0 轨迹和 LM 精度验证
end

% 3. 绘图配置
swDispContRt = [6 4 5 7 8];
swDispContRtLarge = [61 4 5 7];
addpath(genpath('subFunc'),'-begin');

% 4. 绘图执行
if swSN
    plotSN; % 绘制 SN 图
else
    if exist( "rePlotFlag" ) == 0 || rePlotFlag == 0
        PlotAccuracyVerif; % 生成精度验证图
        figLmLine = figure(111); % 创建新图形
        figLmLine.Name = folderName;
        figLmLine.WindowState = 'maximized';
        figPlotCommon; % 设置通用绘图元素
        % ... 设置 xlim, ylim ...
        % ... 清除现有轴 ...
        figPlotPlcm; % 绘制主 LM 图
    end
    % ... 重新绘图逻辑 (rePlotTimer) ...
    SetCollumPlot; % 设置列图
    % ... 信息显示 ...
end


---

## 2.8 LoadData.m
#### 2.8.1 模块说明
`LoadData.m` 脚本负责将特定变量（信号）从 `.mat` 文件加载到 MATLAB 工作空间中。它处理两种主要情况：从 CANape 生成的 MAT 文件加载数据，以及从“重仿真”（re-simulation）结果 MAT 文件加载数据。它还支持加载数据以进行比较。

#### 2.8.2 重点逻辑
1.  **输入 `matName`：** 脚本接收 `matName`（`.mat` 文件的完整路径）作为输入。
2.  **根据 `swCANape` 进行条件加载：**
    *   **如果 `swCANape` 为真：** 直接使用 `load(matName);` 加载 `matName` 文件中的所有变量。
    *   **如果 `swCANape` 为假（重仿真数据）：**
        *   定义 `sigSetCom`（公共信号）和 `sigSet`（主要信号）两组信号，其内容取决于 `swSN` 标志。
        *   分两步加载 `sigSetCom` 和 `sigSet` 中的信号。
        *   如果 `swMapBnd` 为真，加载额外的边界相关信号。
        *   如果 `swComp` 为真，则加载用于比较的数据集。

#### 2.8.3 模块内部交互
`LoadData.m` 脚本主要使用内置的 `load` 函数。

#### 2.8.4 关键伪代码

matlab
% LoadData.m - 数据加载脚本

matName = strcat(dirName, simResName);
if swCANape
    load(matName); % 直接加载所有变量
else
    % 根据 swSN 定义 sigSetCom 和 sigSet
    if swSN
        sigSetCom = {'S_lmInhStt', ...};
        sigSet = {'S_lmmlXCorrM*B', ...};
    else
        sigSetCom = {'S_lmInhStt', ...};
        sigSet = {'S_mpuGnssOriLatLon', ...};
    end
    
    load(matName,sigSetCom{:}); % 加载公共信号
    load(matName,sigSet{:}); % 加载主要信号
    
    if swMapBnd
        load(matName,'S_lmVecMapLnPntDistToBnd*','S_lmVecMapLnPntBndClass*'); % 加载边界信号
    end
    
    if swComp
        % 加载比较数据
        for i = 1:compDataNum
            ORG{i} = load(matNameOrg{i}, sigSetCom{:});
        end
    end
end


---

## 2.9 RePlotLmLine.m
#### 2.9.1 模块说明
`RePlotLmLine.m` 函数是一个回调函数，旨在根据用户与 UI 控件（如编辑框、滑块或按钮）的交互或对时间的编程更改来动态更新 LM 线图 (`figLmLine`)。它实质上是使用更新的参数重新触发 `PlotLmLine.m` 中的绘图逻辑。

#### 2.9.2 重点逻辑
1.  **图形激活和 UI 控件识别：** 激活父图形，并搜索 `slider_obj` 和 `timeEdit_obj` 等时间相关的 UI 控件。
2.  **处理不同的 UI 控件类型：**
    *   **编辑框 (`h.Style == "edit"`)：** 读取新时间，找到 `time` 数组中最近的索引，更新滑块值。
    *   **滑块 (`h.Style == "slider"`)：** 读取滑块值（索引），更新编辑框显示的时间。
    *   **按钮 (`h.Style == "pushbutton"`)：** 根据按钮文本（步长）更新滑块和编辑框的时间。
3.  **处理模式切换 (`h.Tag == "mode"`)：** 根据选定的模式更新 `swXcorr` 变量，并设置 `modeChangeFlag`。
4.  **重新触发绘图：** 设置 `rePlotFlag` 为 1，将 `figLmLine` 句柄赋值给基本工作空间，然后调用 `evalin("base", "PlotLmLine")` 重新执行绘图逻辑。最后清除 `rePlotFlag`。

#### 2.9.3 模块内部交互
`RePlotLmLine.m` 函数通过 `evalin` 调用 `PlotLmLine.m` 脚本。

#### 2.9.4 关键伪代码

matlab
% RePlotLmLine.m - 重新绘制 LM 线图

function RePlotLmLine( h, event )
    parent = h.Parent;
    figure( parent );
    
    % 识别 UI 控件
    % ...

    % 处理不同的 UI 控件类型
    if strcmp( h.Tag, "time" )
        if strcmp( h.Style, "edit" )
            % ... 更新滑块值 ...
        elseif strcmp( h.Style, "slider" )
            % ... 更新编辑框时间 ...
        elseif strcmp( h.Style, "pushbutton" )
            % ... 更新滑块和编辑框时间 ...
        end
    elseif strcmp( h.Tag, "mode" )
        % ... 处理模式切换 ...
    end
    
    % 重新触发绘图
    assignin( "base", "rePlotFlag", 1 );
    assignin( "base", "figLmLine", parent );
    try
        evalin( "base", "PlotLmLine" );
    catch ME
        evalin( "base", "clear rePlotFlag;" );
        rethrow( ME );
    end
    evalin( "base", "clear rePlotFlag;" );
end


---

## 2.10 matchAviFile.m
#### 2.10.1 模块说明
`matchAviFile.m` 函数的目的是在给定的一组 AVI 文件中，找到与特定时间点 (`curPoint`) 对应的 AVI 视频文件。它通过计算 `curPoint` 相对于仿真/录制开始时间的偏移量，然后检查此时间是否落在任何提供的 AVI 文件的持续时间内来完成此操作。

#### 2.10.2 重点逻辑
1.  **函数签名：** 接收 `aviDir`（AVI 文件信息结构体数组）、`curPoint`（要匹配的时间点）和 `simResName`（仿真结果文件名）。
2.  **检索 `VideoTimeInterval`：** 从基本工作空间检索 `VideoTimeInterval`。
3.  **排序 AVI 文件：** 按文件名对 `aviDir` 进行排序。
4.  **初始化：** 初始化 `aviMatchResult` 为 0，`aviName` 为 0，`videoTotalTime` 为 0。
5.  **处理空的 `aviDir`：** 如果 `aviDir` 为空，则立即返回。
6.  **提取仿真开始时间：** 从 `simResName` 中提取时间戳部分，并转换为 `datetime` 对象。
7.  **遍历 AVI 文件：**
    *   获取当前 AVI 文件的持续时间。
    *   从 AVI 文件名中提取当前视频的开始时间，并转换为 `datetime` 对象。
    *   **计算时间偏移：** `calculateTime = curTime + duration(0,0,mod(curPoint,VideoTimeInterval)) - startTime;`。
    *   **匹配检查：** 如果 `abs(curPoint - seconds(calculateTime)) < 120`，则设置 `aviMatchResult` 为 1 并中断循环。

#### 2.10.3 模块内部交互
`matchAviFile.m` 函数主要使用内置的 `VideoReader` 类。

#### 2.10.4 关键伪代码

matlab
% matchAviFile.m - 匹配 AVI 视频文件

function [aviName, aviMatchResult] = matchAviFile(aviDir,curPoint,simResName)
    VideoTimeInterval = evalin('base', 'VideoTimeInterval');
    
    names = {aviDir.name};
    [~, idx] = sort(names);
    aviDir = aviDir(idx);

    aviMatchResult = 0;
    aviName = 0;

    if isempty(aviDir)
        return;
    end
    
    startTime = string(strrep(simResName,'_ACore_XCP_remap.mat',''));
    startTime = datetime(startTime,'InputFormat','yyyyMMdd_HHmmss');

    for k = 1:length(aviDir)
        aviName = aviDir(k).name;
        aviFolder = aviDir(k).folder;
        aviPath = fullfile(aviFolder,aviName);

        v = VideoReader(aviPath);
        videotime = v.Duration;
        
        % 提取当前视频的开始时间
        if contains(aviDir(1).name, '_AXIS_FRONT.avi')
            curTime = string(strrep(aviDir(k).name,'_AXIS_FRONT.avi',''));
        % ... 其他命名约定 ...
        else
            curTime = string(strrep(aviDir(k).name,'_Axis_Camera_Front.avi',''));
        end
        curTime = datetime(curTime,'InputFormat','yyyyMMdd_HHmmss');
        
        % 计算时间偏移
        calculateTime = curTime + duration(0,0,mod(curPoint,VideoTimeInterval)) - startTime;
        
        % 匹配检查
        if abs(curPoint - seconds(calculateTime)) < 120
            aviMatchResult = 1;
            break;
        end
    end
end


---

## 2.11 plotPointFrameOfAvi.m
#### 2.11.1 模块说明
`plotPointFrameOfAvi.m` 函数从 AVI 视频文件中提取给定时间点的特定帧，并将其保存为 PNG 图像。它旨在可视化分析中识别的关键时刻的前置摄像头场景，为问题提供视觉上下文。它生成两个图形（fig152 和 fig153），可能用于不同的时间点或视角。

#### 2.11.2 重点逻辑
1.  **函数签名：** 接收 `curPoint`（第一个帧的时间点）、`curPoint2`（第二个帧的时间点）、`folPath`（AVI 文件路径）、`trueDataName`（数据基础名称）、`curAviNAME`（第一个 AVI 文件名）、`curAviNAME1`（第二个 AVI 文件名）和 `savePicPath`（图片保存路径）。
2.  **检索 `VideoTimeInterval`：** 从基本工作空间检索 `VideoTimeInterval`。
3.  **第一帧生成（针对 `curPoint`）：**
    *   封装在 `try-catch` 块中。
    *   创建新图形 (`fig152`)，设置名称和位置，并隐藏。
    *   格式化 `curPoint` 为 `(min:sec)` 字符串。
    *   使用 `VideoReader` 读取 `curAviNAME` 视频，设置 `CurrentTime`，并读取帧。
    *   在 `axes` 中显示帧，格式化绘图，最大化图形。
    *   将图形保存为 `fig152.png` 到 `savePicPath`。
4.  **第二帧生成（针对 `curPoint2`）：**
    *   仅当 `curPoint2` 为有效数字时间点时执行。
    *   封装在 `try-catch` 块中。
    *   创建新图形 (`fig153`)，设置名称和位置，并隐藏。
    *   格式化 `curPoint2` 为 `(min:sec)` 字符串。
    *   使用 `VideoReader` 读取 `curAviNAME1` 视频，设置 `CurrentTime`，并读取帧。
    *   在 `axes` 中显示帧，格式化绘图，最大化图形。
    *   将图形保存为 `fig153.png` 到 `savePicPath`。

#### 2.11.3 模块内部交互
`plotPointFrameOfAvi.m` 函数主要使用内置的 `VideoReader` 类。

#### 2.11.4 关键伪代码

matlab
% plotPointFrameOfAvi.m - 绘制 AVI 视频帧

function plotPointFrameOfAvi(curPoint,curPoint2,folPath,trueDataName,curAviNAME,curAviNAME1,savePicPath)
    try
        VideoTimeInterval = evalin('base', 'VideoTimeInterval');
        
        % 1. 第一帧生成 (fig152)
        fig152=figure('Name',strcat('152  Time:',string( mod(curPoint,VideoTimeInterval) )),'Position',[0 0 screenSize(3:4)],'Visible',0); clf;
        % ... 时间格式化 ...
        aviAx = subplot(1,1,[1 1]);
        curVideo=VideoReader(fullfile(folPath,curAviNAME)); 
        curVideo.CurrentTime=mod(curPoint,VideoTimeInterval);
        aviFrames=readFrame(curVideo);
        image(aviAx,aviFrames);
        % ... 绘图格式化 ...
        saveas(fig152,strcat(savePicPath,'\fig152.png'));
    catch
    end
    
    try
        if ~isstring(curPoint2)
            % 2. 第二帧生成 (fig153)
            fig153=figure('Name',strcat('153  Time:',string( mod(curPoint2,VideoTimeInterval) )),'Position',[0 0 screenSize(3:4)],'Visible',0); clf;
            % ... 时间格式化 ...
            aviAx2 = subplot(1,1,[1 1]);
            curVideo=VideoReader(fullfile(folPath,curAviNAME1)); 
            curVideo.CurrentTime=mod(curPoint2,VideoTimeInterval);
            aviFrames=readFrame(curVideo);
            image(aviAx2,aviFrames);
            % ... 绘图格式化 ...
            saveas(fig153,strcat(savePicPath,'\fig153.png'));
        end
    catch
    end
end


---

## 2.12 savePicsToExc_V20.m
#### 2.12.1 模块说明
`savePicsToExc_V20.m` 函数负责将预生成的图像文件（PNG）嵌入到 Excel 工作表中的特定单元格中。它接收图像路径和目标 Excel 工作表/范围，然后使用 COM 自动化插入和定位图像。

#### 2.12.2 重点逻辑
1.  **函数签名：** 接收 `Sheets`（Excel `Sheets` 对象）、`excAbsPath`（Excel 文件绝对路径）、`trueDataName`（数据基础名称）、`justPoint`（时间点）和 `savePicPath`（图片保存路径）。
2.  **目标工作表激活：** 根据 `trueDataName` 和 `justPoint` 获取并激活目标工作表。获取 `Shapes` 集合。
3.  **图像嵌入循环：** 遍历 `pos` 从 1 到 5（以及其他注释掉的块），每个 `pos` 对应一个图像及其在 Excel 中的目标位置。
    *   构建 PNG 图像文件的完整路径。
    *   使用 `try-catch` 处理图像文件不存在的情况。
    *   使用 `Shapes.AddPicture` 插入图像，并根据 Excel 单元格范围的属性动态计算图像的位置和大小，确保图像嵌入到预格式化的区域中。
    *   图像映射：
        *   `pos=1`：`LmLineFig1.png` 到 `A11:M41`
        *   `pos=2`：`fig152.png` 到 `O11:AA41`
        *   `pos=3`：`LmLineFig1_1.png` 到 `AC11:AO41`
        *   `pos=4`：`LmLineFig3.png` 到 `A48:M78`
        *   `pos=5`：`fig153.png` 到 `O48:AA78`

#### 2.12.3 模块内部交互
`savePicsToExc_V20.m` 函数主要通过 Excel COM 自动化（`Shapes.AddPicture`）进行交互。

#### 2.12.4 关键伪代码

matlab
% savePicsToExc_V20.m - 将图片保存到 Excel

function savePicsToExc_V20(Sheets,excAbsPath,trueDataName,justPoint,savePicPath)
    Sheet1 = get(Sheets,'Item',strcat(trueDataName,'_',string(justPoint)) );
    Sheet1.Activate;
    Shapes = Sheet1.Shape;
    
    for pos = 1:5
        if pos==1
            try
                shape = Shapes.AddPicture(fullfile(pwd,strcat(savePicPath,'\LmLineFig1.png')),0,1,1,1,1,1);
                shape.Left = Sheet1.Range( strcat('A',string(1+10),':','M',string(1+40)) ).Left;
                % ... 设置 Top, Width, Height ...
            catch
                disp('No LmLineFig1 pic!');
            end
        end
        % ... 其他 pos 对应的图片嵌入逻辑 ...
        if pos==2
            try
                shape = Shapes.AddPicture(fullfile(pwd,strcat(savePicPath,'\fig152.png')),0,1,1,1,1,1);  
                shape.Left = Sheet1.Range( strcat('O',string(1+10),':','AA',string(1+40)) ).Left;
                % ... 设置 Top, Width, Height ...
            catch
                disp('No fig152 pic!');
            end
        end
        % ... (pos=3, pos=4, pos=5 类似) ...
    end
end

# L03 解析模块详细设计

## 2.1 main.m
#### 2.1.1 模块说明
`main.m` 是 L03 分析报告生成的主要入口点。它协调数据加载、处理和 Excel 报告生成，但专门针对 L03 相关问题。它处理多个 Excel 文件（可能用于不同版本或运行），并遍历它们。

#### 2.1.2 重点逻辑
1.  **初始化与路径设置：** 记录开始时间，将 `Scripts` 和 `Scripts/subFunc` 子目录添加到 MATLAB 路径。定位 L03 Excel 报告文件，并定义数据文件夹路径。
2.  **`writeDataNameIssue;`：** 调用 `writeDataNameIssue.m`，负责将初始数据名称和问题信息写入 L03 Excel 文件。
3.  **Excel 文件迭代：** 查找所有 L03 Excel 文件并按数字排序，然后遍历每个 Excel 文件。
4.  **`createExcelSheet;`：** 调用 `createExcelSheet.m`，负责动态创建新工作表并建立超链接。
5.  **每个 Excel 文件的处理循环：**
    *   **数据提取：** 从 Excel 中提取数据名称和问题时间点。
    *   **数据分组：** 按数据名称对数据进行分组。
    *   **每个数据名称的处理循环：**
        *   **数据加载：** 加载相关的 MAT 文件。
        *   **`obtainCorrectTime`：** 调用 `obtainCorrectTime` 进行时间校正。
        *   **冻结标志检查：** 检查文件名中是否存在“Freeze”，并更新 Excel。
        *   **`writeLinkID`：** 调用 `writeLinkID` 写入链接 ID。
        *   **`GoogleMapLinks;`：** 调用 `GoogleMapLinks.m` 生成 Google 地图链接。
        *   **`start_BEV;`：** 调用 `start_BEV.m` 生成 BEV 绘图和比较。
        *   **每个问题点的处理循环：**
            *   创建临时图片保存目录。
            *   填充车辆编号。
            *   **`matchAviFile`：** 调用 `matchAviFile` 匹配 AVI 文件。
            *   **`plotPointFrameOfAvi`：** 调用 `plotPointFrameOfAvi` 生成网络摄像头图片。
        *   保存 Excel。
6.  **最终 Excel 格式化和图像嵌入：** 如果存在超链接，重新打开 Excel，添加超链接，应用广泛格式，并调用 `savePicsToExc` 嵌入图片。
7.  **性能测量和清理：** 记录总耗时，并移除 MATLAB 路径。

#### 2.1.3 模块内部交互
`main.m` 脚本通过 `actxserver` 与 Excel 应用程序进行 COM 自动化交互，并调用以下外部 MATLAB 脚本或函数：
*   `writeDataNameIssue.m`：写入初始问题数据。
*   `createExcelSheet.m`：创建和初始化 Excel 工作表。
*   `writeLinkID.m`：从 MPU 数据中提取链接 ID 并写入 Excel。
*   `GoogleMapLinks.m`：生成 Google 地图链接。
*   `obtainCorrectTime.m`：校正时间数据。
*   `start_BEV.m`：生成 BEV 绘图和比较。
*   `matchAviFile.m`：匹配 AVI 视频文件。
*   `plotPointFrameOfAvi.m`：从 AVI 文件中提取帧并保存为图片。
*   `savePicsToExc.m`：将图片嵌入到 Excel 工作表中。

#### 2.1.4 关键伪代码

matlab
% main.m - L03 分析报告生成主脚本

L03StartTime = clock;
addpath(fullfile(pwd,'Scripts'));
addpath(fullfile(pwd,'Scripts','subFunc'));

% 1. 初始化和路径设置
excFilePath = dir(fullfile(currentDir,'data\L03_Analysis\L03_*'));
excAbsPath=fullfile(excPath,excFile);

% 2. writeDataNameIssue;
writeDataNameIssue;

% 3. Excel 文件迭代
ExcelFilePath1 = dir(fullfile(currentDir,'data\L03_Analysis\L03̓GNZ*'));
for j = 1:length(ExcelFilePath1)
    % ... 构建 ExcelFilePath ...
end

% 4. createExcelSheet;
createExcelSheet;

for kk = 1:length(ExcelFilePath)
    excAbsPath = ExcelFilePath(kk);
    % 5. 每个 Excel 文件的处理循环
    [~,~,excRaw]=xlsread(excAbsPath);
    dataNameColu=string(excRaw(:,4));
    pointColu=string(excRaw(:,5));
    dataNameArr = horzcat(dataNameColu,pointColu);
    
    dataFolderArr = containers.Map('KeyType', 'char', 'ValueType', 'any');
    for i = 1:size(dataNameArr, 1)
        % ... 数据分组逻辑 ...
    end
    
    keys = cellstr(unique(dataNameArr(:, 1), 'stable'));
    for i = 1:length(keys)
        key = keys{i};
        timeValues = dataFolderArr(key);

        % 数据加载
        trueDataNameAll=key;
        folPath = fullfile(dataFolder,trueDataNameAll);
        % ... 加载 MAT 文件 ...
        
        S_Group1Time.signals.values = obtainCorrectTime(S_Group1Time.signals.values); % 时间校正

        % 冻结标志检查
        % ...
        
        excRaw = writeLinkID(excRaw,folPath,trueDataName,curPointStingArr); % 写入链接 ID
        result = xlswrite(excAbsPath,excRaw);
        GoogleMapLinks; % 生成 Google 地图链接
        start_BEV; % 生成 BEV 绘图和比较

        % 每个问题点的处理循环
        for j=1:length(dataTimeArr)
            savePicPath = strcat('tempSavePic\',strcat(trueDataNameAll,'_',dataTimeArr(j)));
            if ~exist(savePicPath, 'dir')
                mkdir(savePicPath);
            end
            excRaw(h+2,2) = cellstr(VelName); % 填充车辆编号
            [aviMatchNameArray, aviMatchResultArray] = matchAviFile(AviFiles,rawCurpoint,curAcoreXCPNAME1.name); % 匹配 AVI 文件
            plotPointFrameOfAvi(rawCurpoint,folPath,trueDataName,aviMatchNameArray,aviMatchResultArray, savePicPath); % 生成网络摄像头图片
        end
        result = xlswrite(excAbsPath,excRaw);
    end
    
    % 6. 最终 Excel 格式化和图像嵌入
    if hyperlinkAll ~= ""
        Excel = actxserver('Excel.Application');
        Workbook = Workbooks.Open(excAbsPath);
        % ... 添加超链接，设置格式 ...
        savePicsToExc(Sheets,trueDataName,rawCurpoint,savePicPath); % 嵌入图片
        Workbook.Save;
        Excel.Quit;
        Excel.delete;
    end
end

% 7. 性能测量和清理
L03EndTime = clock;
elapsed_time = etime(L03EndTime, L03StartTime);
fprintf('L03 total waste time: %.1f[s]\n', elapsed_time);
rmpath(fullfile(pwd,'Scripts'));
rmpath(fullfile(pwd,'Scripts','subFunc'));


---

## 2.2 writeDataNameIssue.m
#### 2.2.1 模块说明
`writeDataNameIssue.m` 脚本负责从“OnlyA”Excel 文件（可能代表问题的子集或特定类型的分析）中提取问题数据，并将其填充到 L03 Excel 报告中。它处理“OnlyA”数据可能太大而无法放入单个工作表的情况，将其拆分为多个 L03 Excel 文件。

#### 2.2.2 重点逻辑
1.  **路径设置：** 构建到“A”目录的路径，并在 `data/IssueList/A/` 中查找“OnlyA”Excel 文件。
2.  **遍历“OnlyA”文件：** 遍历找到的每个“OnlyA”Excel 文件。
    *   **读取“OnlyA”Excel：** 使用 `xlsread` 读取内容。
    *   **提取数据：** 提取 `OnlyAdataName`、`OnlyAdataIssue`、`OnlyAdataNameMf4Name` 和 `OnlyAwalkDiff`。进行基本验证。
    *   使用 `horzcat` 将提取的数据组合到 `OnlyAdata` 中。
3.  **填充 L03 Excel（单个文件情况）：** 如果 `OnlyAdata` 行数小于 16，则假定数据适合单个 L03 Excel 文件。创建目录，读取 L03 Excel 模板，填充特定列，构建新文件名，复制模板，并写入数据。
4.  **填充 L03 Excel（多个文件情况）：** 如果数据太大，则使用 `splitArray(OnlyAdata)` 拆分 `OnlyAdata`。遍历每个子数组，构建新文件名，复制模板，并写入数据。

#### 2.2.3 模块内部交互
`writeDataNameIssue.m` 脚本调用 `splitArray.m`，并使用内置的 `xlsread` 和 `xlswrite`。

#### 2.2.4 关键伪代码

matlab
% writeDataNameIssue.m - 写入问题数据到 Excel

Aexcel = strrep(excPath,'L03_Analysis','A');
OnlyA = dir(fullfile(currentDir,'data\IssueList\A\*_OnlyMF4*'));
excelNum = 1;

for i = 1:length(OnlyA)
    [~,~,OnlyAexcel]=xlsread(fullfile(OnlyA(i).folder,OnlyA(i).name));
    OnlyAdataName = rmmissing(string(OnlyAexcel(6:end,2)));
    OnlyAdataIssue = rmmissing(string(OnlyAexcel(6:end,4)));
    if length(OnlyAdataName)~=length(OnlyAdataIssue)
        error('Error the number of OnlyA data does not match the number of issue')
    end
    OnlyAdata = horzcat(OnlyAdataName,OnlyAdataIssue);
    OnlyAdataNameMf4Name = rmmissing(string(OnlyAexcel(6:end,43)));
    OnlyAwalkDiff = rmmissing(string(OnlyAexcel(6:end,7)));
    OnlyAdata = horzcat(OnlyAdata, OnlyAdataNameMf4Name);
    OnlyAdata = horzcat(OnlyAdata, OnlyAwalkDiff);
    
    if length(OnlyAdata(:,1))<16
        % 单个文件情况
        mkdir(fullfile(string(excPath)));
        [~,~,excelData] = xlsread(excAbsPath);
        excelData(3:length(OnlyAdata(:,1))+2,4) = cellstr(OnlyAdata(:,1));
        excelData(3:length(OnlyAdata(:,2))+2,5) = cellstr(OnlyAdata(:,2));
        excelData(3:length(OnlyAdata(:,3))+2,6) = cellstr(OnlyAdata(:,3));
        excelData(3:length(OnlyAdata(:,4))+2,25) = cellstr(OnlyAdata(:,4));
        excAbsPath1 = fullfile(excPath,strcat('L03̓GNZ_',split_data{1},'_dl',l03_specification_ver,'_͊',soft_ver,strcat('_',string(excelNum)),'.xlsx'));
        copyfile(excAbsPath,excAbsPath1);
        excelNum = excelNum+1;
        xlswrite(excAbsPath1,excelData);
    else
        % 多个文件情况
        subArray = splitArray(OnlyAdata);
        for j = 1:length(subArray.array)
            subOnlyAdata = subArray.array(1,j);
            subOnlyAdata = string(subOnlyAdata{1,1});
            if ~isempty(subOnlyAdata)
                L03fileName = strcat('L03̓GNZ_',split_data{1},'_dl',l03_specification_ver,'_͊',soft_ver,strcat('_',string(excelNum)),'.xlsx');
                L03filePath(end+1) = fullfile(string(excPath),L03fileName);
                copyfile(excAbsPath,L03filePath(end));
                excelNum = excelNum+1;
                [~,~,excelData] = xlsread(L03filePath(end));
                [rowSub,~] = size(subOnlyAdata);
                excelData(3:rowSub+2,4) = cellstr(subOnlyAdata(:,1));
                excelData(3:rowSub+2,5) = cellstr(subOnlyAdata(:,2));
                excelData(3:rowSub+2,6) = cellstr(subOnlyAdata(:,3));
                excelData(3:rowSub+2,25) = cellstr(subOnlyAdata(:,4));
                xlswrite(L03filePath(end),excelData);
            end
        end
    end
end


---

## 2.3 splitArray.m
#### 2.3.1 模块说明
`splitArray.m` 函数接受一个二维数组 (`withAdata`) 并将其拆分为较小的子数组，每个子数组最多包含 15 行。它旨在对大型数据集进行分页或分块，以便将其放入单独的 Excel 工作表或部分中。

#### 2.3.2 重点逻辑
1.  **函数签名：** 接收 `withAdata`（要拆分的输入二维数组）。
2.  **初始化：** 初始化 `subArray` 结构体，获取输入数组的总行数 `maxLength`，并计算所需的子数组数量 `numGroups`（每组最多 15 行）。
3.  **拆分循环：** 遍历 `numGroups` 次。对于除最后一个组之外的所有组，提取 15 行数据。对于最后一个组，提取剩余的所有行数据。将每个子数组存储在 `subArray.array` 单元格数组中。

#### 2.3.3 模块内部交互
`splitArray.m` 函数不调用其他脚本或函数，仅使用基本的 MATLAB 数组索引和操作。

#### 2.3.4 关键伪代码

matlab
% splitArray.m - 拆分二维数组

function subArray = splitArray(withAdata)
    subArray = struct();
    maxLength = length(withAdata(:,1));
    numGroups = ceil(maxLength / 15);
    for i = 1:numGroups
        if i ~= numGroups
            subArray.array{i} = withAdata(1+(i-1)*15:15+(i-1)*15,:);
        else
            subArray.array{i} = withAdata(1+(i-1)*15:maxLength,:);
        end
    end
end


---

## 2.4 obtainCorrectTime.m
#### 2.4.1 模块说明
`obtainCorrectTime.m` 函数旨在校正或调整时间序列数据，特别是针对 `S_Group1Time.signals.values`。它处理两种主要情况：来自 CANape 的数据（可能会根据信号长度调整时间）和非 CANape 数据（会根据 0.05 秒的间隔填充缺失的时间值）。

#### 2.4.2 重点逻辑
1.  **函数签名：** 使用 `varargin` 接受可变数量的输入参数。如果只有一个参数，则假定它是 `S_Group1Time.signals.values`。
2.  **`swCANape` 确定：** 如果只有一个输入参数，`swCANape` 被硬编码为 0，这意味着它将执行非 CANape 数据的处理逻辑。
3.  **时间校正（非 CANape 数据）：** 遍历时间数组，如果遇到零值，则根据前一个非零时间点和 0.05 秒的采样间隔外推填充时间。
4.  **`TimeColAdjst` 子函数：** 这是一个嵌套函数，用于调整时间列的长度。在此上下文中，由于 `swCANape` 始终为 0，此子函数不会被调用。

#### 2.4.3 模块内部交互
`obtainCorrectTime.m` 函数不调用其他脚本或函数，仅使用基本的 MATLAB 数组操作。

#### 2.4.4 关键伪代码

matlab
% obtainCorrectTime.m - 校正时间序列数据

function time = obtainCorrectTime(varargin)
    numArgs = nargin;
    if numArgs == 1
        swCANape = 0;
        S_Group1Time.signals.values = varargin{1};
    else
        % ... (未实现其他参数情况) ...
    end
    
    if swCANape == 0
        time = S_Group1Time.signals.values;
        onFlg = 0;
        for i = 2:length(time)
            if time(i) ~= 0
                not0TimeSmpl = i;
                onFlg = 1;
            elseif onFlg
                time(i) = time(not0TimeSmpl)+(i-not0TimeSmpl)*0.05;
            end
        end    
    end
end

function GroupTime = TimeColAdjst(GroupTimeIn, varLen)
    % ... (此子函数在此上下文中为死代码) ...
end


---

## 2.5 start_BEV.m
#### 2.5.1 模块说明
`start_BEV.m` 脚本是 L03 分析的核心组件，专门用于从 MF4（原始数据）和 Resim（仿真结果）数据生成和保存鸟瞰图 (BEV) 绘图。它遍历问题点，在这些点和周围时间生成 BEV 绘图，并将其保存为 PNG 图像。它还使用 MF4 和 Resim BEV 数据之间的比较结果更新 Excel 报告。

#### 2.5.2 重点逻辑
1.  **初始化：** 初始化 `mf4` 前缀变量，保存当前工作空间变量。
2.  **MF4 BEV 绘图生成：**
    *   设置 `dirName`、`folderName`、`simResName`。
    *   调用 `PlotLmLine;` 加载 MF4 数据并生成初始 LM 绘图。
    *   最大化图形窗口，存储 `eMap`、`eYRM`、`time` 到 `mf4eMap`、`mf4eYRM`、`mf4time`。
    *   遍历 `curPointArr`，为每个问题点创建图片目录，设置 `timeEdit_obj.String`，调用 `RePlotLmLine` 更新绘图，捕获图形并保存为 `mf4BEV.png`。
    *   生成围绕 `rawCurpoint` 的额外 BEV 绘图，并保存为 `mf4BEV<fig_i>.png`。
    *   关闭所有图形并清除变量。
3.  **Resim BEV 绘图生成：**
    *   保存当前工作空间变量。
    *   设置 `dirName`、`folderName`、`simResName`。
    *   调用 `PlotLmLine;` 加载 Resim 数据。
    *   最大化图形窗口，存储 `eMap`、`eYRM` 到 `resimeMap`、`resimeYRM`。计算 `resimCurvR`。
    *   遍历 `curPointArr`，如果未冻结，则设置 `timeEdit_obj.String`，调用 `RePlotLmLine` 更新绘图，捕获图形并保存为 `resimBEV.png`。
    *   生成围绕 `rawCurpoint` 的额外 BEV 绘图。
    *   **Excel 更新（比较）：** 比较 `resimeMap` 与 `mf4eMap`，`resimeYRM` 与 `mf4eYRM`，并更新 `excRaw` 中相关列的比较结果。
4.  **Resim Model2 BEV 绘图生成：**
    *   设置 `listbox_obj.Value = 2`，调用 `RePlotLmLine` 切换绘图模式。
    *   遍历 `curPointArr`，生成并保存 `resimModel2BEV.png` 和周围绘图。
5.  **最终 Excel 更新和清理：** 保存更新后的 Excel 数据，关闭所有图形，清除相关变量。

#### 2.5.3 模块内部交互
`start_BEV.m` 脚本调用以下外部 MATLAB 脚本或函数：
*   `PlotLmLine.m`：生成 LM 绘图。
*   `RePlotLmLine.m`：重新绘制 LM 绘图。

#### 2.5.4 关键伪代码

matlab
% start_BEV.m - BEV 绘图和比较脚本

mf4eMap = []; mf4eYRM = []; mf4time = [];
vars_mf4_BEV = who;

% 1. MF4 BEV 绘图生成
dirName = strcat(dataFolder, '\', trueDataNameAll, '\');
folderName = trueDataNameAll;
simResName = curAcoreXCPNAME1.name;
PlotLmLine; % 加载 MF4 数据并绘图
frame_h = get(handle(gcf),'JavaFrame');
set(frame_h,'Maximized',1);

mf4eMap = eMap; mf4eYRM = eYRM; mf4time = time;
% ... 计算 mf4MinPoint, mf4MaxPoint ...

for ci = 1:length(curPointArr)
    savePicPath = strcat('tempSavePic\',strcat(trueDataNameAll,'_',dataTimeArr(ci)));
    if ~exist(savePicPath, 'dir')
        mkdir(savePicPath);
    end
    rawCurpoint = rawCurpointArr(ci);

    timeEdit_obj.String=string(rawCurpoint);
    RePlotLmLine( timeEdit_obj ); % 更新绘图
    mf4BEV = figLmLine;
    imwrite(frame.cdata, strcat(savePicPath,'\mf4BEV.png'),'BitDepth', 16);

    % 生成周围绘图
    range_fig = -1:0.1:1;
    for fig_i = 1:length(range_fig)
        % ... 生成并保存 mf4BEV<fig_i>.png ...
    end
end
close all;
clearvars -except vars_mf4_BEV;

vars_resim_BEV = who;
% 2. Resim BEV 绘图生成
dirName = strcat(dataFolder, '\', trueDataNameAll, '\');
folderName = trueDataNameAll;
simResName = curSfuncNAME1.name;
PlotLmLine; % 加载 Resim 数据并绘图
frame_h = get(handle(gcf),'JavaFrame');
set(frame_h,'Maximized',1);

resimeMap = eMap; resimeYRM = eYRM;
% ... 计算 resimCurvR ...

for ci = 1:length(curPointArr)
    curFreezeFlag = freezeArr(ci);
    if ~curFreezeFlag 
        % ... 生成并保存 resimBEV.png ...
        % ... 生成周围绘图 ...
        % Excel 更新（比较）
        excRaw(h+2,29) = cellstr("~"); % 示例：不匹配
        excRaw(h+2,26) = cellstr("Z"); % 示例：匹配
    end
end

% 3. Resim Model2 BEV 绘图生成
listbox_obj.Value = 2;
RePlotLmLine( listbox_obj ); % 切换绘图模式
for ci = 1:length(curPointArr)
    curFreezeFlag = freezeArr(ci);
    if ~curFreezeFlag 
        % ... 生成并保存 resimModel2BEV.png ...
        % ... 生成周围绘图 ...
    end
end

% 4. 最终 Excel 更新和清理
result = xlswrite(excAbsPath,excRaw);
close all;
clearvars -except vars_resim_BEV;
clearvars mf4eMap mf4eYRM mf4time mf4MinPoint mf4MaxPoint;


---

## 2.6 savePicsToExc.m
#### 2.6.1 模块说明
`savePicsToExc.m` 函数负责将各种预生成的图像文件（PNG）嵌入到 Excel 工作表中的特定单元格中。它旨在用视觉数据填充 L03 分析工作表，包括 MF4 BEV、Resim BEV、Resim Model2 BEV 和 AVI 帧。它还处理嵌入围绕中心点的一系列图像。

#### 2.6.2 重点逻辑
1.  **函数签名：** 接收 `Sheets`（Excel `Sheets` 对象）、`trueDataName`（数据基础名称）、`justPoint`（时间点）和 `savePicPath`（图片保存路径）。
2.  **目标工作表激活：** 根据 `trueDataName` 和 `justPoint` 获取并激活目标工作表。获取 `Shapes` 集合。
3.  **嵌入主图像：** 尝试将 `mf4BEV.png`、`figAvi.png`、`resimBEV.png` 和 `resimModel2BEV.png` 嵌入到预定义的 Excel 范围中。每个嵌入都封装在 `try-catch` 块中。
4.  **嵌入周围图像（系列帧）：** 定义一个偏移范围（例如 -1.0 到 1.0），遍历该范围，构建每个图像的路径，并将其嵌入到动态计算的 Excel 范围中。这包括 `mf4BEV<fig_i>.png`、`figAvi<fig_i>.png`、`resimBEV<fig_i>.png` 和 `resimModel2BEV<fig_i>.png`。

#### 2.6.3 模块内部交互
`savePicsToExc.m` 函数主要通过 Excel COM 自动化进行交互。

#### 2.6.4 关键伪代码

matlab
% savePicsToExc.m - 将图片保存到 Excel

function savePicsToExc(Sheets,trueDataName,justPoint,savePicPath)
    Sheet1 = get(Sheets,'Item',strcat(trueDataName,'_',string(justPoint)) );
    Sheet1.Activate;
    Shapes = Sheet1.Shape;
    
    % 1. 嵌入主图像
    try
        shape = Shapes.AddPicture(fullfile(pwd,strcat(savePicPath,'\mf4BEV.png')),0,1,1,1,1,1);
        shape.Left = Sheet1.Range('A5:M35').Left;
        shape.Top = Sheet1.Range('A5:M35').Top;
        shape.Width = Sheet1.Range('A5:M35').Width;
        shape.Height = Sheet1.Range('A5:M35').Height;
    catch
        disp('No mf4BEV pic!');
    end
    % ... (figAvi.png, resimBEV.png, resimModel2BEV.png 类似) ...

    % 2. 嵌入周围图像（系列帧）
    range_fig = -1:0.1:1;
    range_fig = range_fig(range_fig ~= 0);
    for fig_i = 1:length(range_fig)        
        mf4BEVPath = strcat(savePicPath,strcat('\mf4BEV',num2str(fig_i),'.png'));
        figAviPath = strcat(savePicPath,strcat('\figAvi',num2str(fig_i),'.png'));
        resimBEVPath = strcat(savePicPath,strcat('\resimBEV',num2str(fig_i),'.png'));
        resimModel2BEVPath = strcat(savePicPath,strcat('\resimModel2BEV',num2str(fig_i),'.png'));

        mf4BEVRange = strcat('A', string(46 + 35*(fig_i -1)), ':', 'M', string(76+35*(fig_i -1)));
        % ... (figAviRange, resimBEVRange, resimModel2BEVRange 类似) ...

        try
            shape = Shapes.AddPicture(fullfile(pwd,mf4BEVPath),0,1,1,1,1,1);
            shape.Left = Sheet1.Range(mf4BEVRange).Left;
            % ... 设置 Top, Width, Height ...
        catch
            fprintf('No mf4BEV%d pic!\n', fig_i);
        end
        % ... (figAvi, resimBEV, resimModel2BEV 类似) ...
    end
end

# ParaPara 生成模块详细设计

## 2.1 GenerateOnlyMF4Para.m
#### 2.1.1 模块说明
`GenerateOnlyMF4Para.m` 脚本旨在专门为 MF4 数据生成“ParaPara”（可能是一种分析报告或可视化）。它遍历一组 MF4 数据文件，加载相关数据，使用 `PlotLmLine.m` 生成图表，然后使用 `createOnlyMF4Parapara.m` 创建“ParaPara”输出。

#### 2.1.2 重点逻辑
1.  **路径设置和数据识别：** 定义转换后的 MAT 数据路径。根据 `sw_DataType` 识别 `simResNames`，并查找原始 MF4 数据文件。将 `subFunc` 目录添加到 MATLAB 路径。
2.  **条件执行：** 核心逻辑仅在 `OnlyMF4ParaA` 或 `OnlyMF4ParaB` 标志为真时执行。
3.  **主处理循环：** 遍历每个原始 MF4 数据文件。
    *   **变量保留：** 保存当前工作空间变量，以便在处理每个文件后恢复。
    *   **文件名和路径提取：** 提取 `simResName`、`folderName`、`dataDate`、`dirName` 和 `PlusName`。
    *   **`PlotLmLine;`：** 调用 `PlotLmLine.m` 加载 MF4 数据并生成初始 LM 图。
    *   **`createOnlyMF4Parapara;`：** 调用 `createOnlyMF4Parapara.m` 生成“ParaPara”输出。
    *   **清理：** 清除循环中引入的变量。
4.  **最终清理：** 更改目录并从 MATLAB 路径中删除 `subFunc`。

#### 2.1.3 模块内部交互
`GenerateOnlyMF4Para.m` 脚本调用以下外部 MATLAB 脚本或函数：
*   `PlotLmLine.m`：生成 LM 图。
*   `createOnlyMF4Parapara.m`：生成“ParaPara”输出。

#### 2.1.4 关键伪代码

matlab
% GenerateOnlyMF4Para.m - 仅 MF4 ParaPara 生成脚本

matdata = fullfile(currentDir,'data','matdata');
% ... 数据识别逻辑 ...
addpath('.\subFunc');

if OnlyMF4ParaA || OnlyMF4ParaB
    for k = 1:length(onlyMF4DataName)
        vars = who;
        simResName = strrep(onlyMF4DataName(k).name,'.mat','');
        folderName = split(simResNames(k).folder,'\');
        dataDate = char(folderName(end));
        dataDate = string(dataDate(1:8));
        folderName = string(folderName(end));
        dirName = strrep(simResNames(k).folder,folderName,'');
        PlusName = string(regexp(folderName,'_Plus\d+','match'));
        onlyMF4DataNamePath = fullfile(onlyMF4DataName(k).folder,onlyMF4DataName(k).name);

        PlotLmLine; % 加载 MF4 数据并生成初始 LM 图
        createOnlyMF4Parapara; % 生成“ParaPara”输出

        cmd = 'clearvars -except ';
        cmd = [cmd, strjoin(vars, ' ')];
        eval(cmd);
    end
end
cd(fullfile(currentDir,'Parapara','Analysis','PlotLoc','OnlyMF4'));
rmpath('.\subFunc');


---

## 2.2 createOnlyMF4Parapara.m
#### 2.2.1 模块说明
`createOnlyMF4Parapara.m` 脚本专门为 MF4 数据生成详细的分析报告（称为“ParaPara”）。它识别数据中的各种“问题点”或“标志”，对其进行分类，然后围绕这些点生成一系列图表（可能是鸟瞰图或类似图表），并将其保存为 PNG 图像到结构化目录中。它还对 PLD（感知车道偏离）标志执行一些重叠处理。

#### 2.2.2 重点逻辑
1.  **路径和文件夹设置：** 提取 `LMsoftVer`，构建 `dataFolderName` 和 `dirName_PLD`，并定义输出目录。创建这些目录。
2.  **PLD 标志处理：** 清除 `lmPldStt` 中的特定位。计算 `LMPldSttIdxInvZ` 和 `chkPLDFlgIdx`。调用 `PLDoverLap.m` 处理 PLD 重叠。创建 PLD 文件夹。
3.  **间隙搜索和索引选择：** 根据 `tgtDiffy` 和 `eMap` 识别数据中的“间隙”，并识别这些间隙周围的“选择”索引。
4.  **“ParaPara A”绘图生成：** 如果 `OnlyMF4ParaA` 为 1，则遍历“选择”索引。
    *   创建图形并设置子图布局。
    *   调用 `SelectPlot2.m` 绘制各种信号。
    *   有条件地绘制车道。
    *   设置绘图格式，添加注释。
    *   调用 `SetTimePlot_r06.m` 和 `RankBTimePlot.m`。
    *   保存图像并关闭图形。
5.  **“ParaPara B”绘图生成：** 如果 `OnlyMF4ParaB` 为 1，则遍历每个 PLD 标志。
    *   处理 `chkPLDFlgIdx` 以识别特定 PLD 事件。
    *   调用 `detailClassificationResim.m` 对 PLD 事件进行分类。
    *   执行与“ParaPara A”类似的绘图循环，保存图像到 PLD 特定子目录。

#### 2.2.3 模块内部交互
`createOnlyMF4Parapara.m` 脚本调用以下外部 MATLAB 脚本或函数：
*   `PLDoverLap.m`：处理 PLD 重叠。
*   `SelectPlot2.m`：绘制各种信号。
*   `SetTimePlot_r06.m`：生成时域图。
*   `RankBTimePlot.m`：生成 Rank B 信号图。
*   `detailClassificationResim.m` (条件性)：对 PLD 事件进行分类。

#### 2.2.4 关键伪代码

matlab
% createOnlyMF4Parapara.m - 仅 MF4 ParaPara 生成核心脚本

LMsoftVer = char(regexp(simResNames(k).name,'LM(\w{6})','match'));
LMsoftVer = string(LMsoftVer(3:8));
dataFolderName = folderName+"_SavePara_OnlyMF4_LM"+LMsoftVer;
dirName_PLD = folderName+"_SavePara_PLD_OnlyMF4_LM"+LMsoftVer;
folderNamee = fullfile(currentDir,'data','paraSave','A',dataDate,dataFolderName);
folderName_PLD = fullfile(currentDir,'data','paraSave','B',dataDate,dirName_PLD);

if exist(folderNamee, 'dir')==0
    mkdir(folderNamee);
end
if exist(folderName_PLD, 'dir')==0
    mkdir(folderName_PLD);
end

% 1. PLD 标志处理
for j=29:32
    lmPldStt = bitset(lmPldStt,j,0);
end
LMPldSttIdxInvZ = [0;double(lmPldStt(1:end-1)==0)];
% ... chkFlgListAll, chkFlgNameList 定义 ...
chkFlgListTmp = [];
for i=1:length(chkFlgListAll)
    chkFlgListTmp = [chkFlgListTmp,eval(chkFlgListAll(i))];
end
chkPLDFlgIdx = double(chkFlgListTmp).*LMPldSttIdxInvZ;
PLDoverLap; % 处理 PLD 重叠

% 创建 PLD 文件夹
folderName_PLDList = [];
for pldDirIdx = 1:length(chkFlgNameList)
    folderName_PLDPart = folderName_PLD+"/"+chkFlgNameList(pldDirIdx);
    folderName_PLDList = [folderName_PLDList,folderName_PLDPart];
end

% 2. 间隙搜索和索引选择
gapValue = tgtDiffy;
ZZ_search03mGapStep = [];
if isempty(find(bitget(S_lmInhStt.signals.values,3) == 1, 1))
    % ... 间隙搜索逻辑 ...
else
    % ... 间隙搜索逻辑 ...
end
% ... 索引处理逻辑 ...

% 3. “ParaPara A”绘图生成
if OnlyMF4ParaA == 1
    for pickUpIndexCnt=1:length(ZZ_pickUpIndex)
        l=ZZ_pickUpIndex(pickUpIndexCnt);
        figParaA=figure('visible','off');clf;
        % ... 图形设置 ...
        ax99 = subplot(9,4,[1,2,5,6,9,10,13,14,17,18,21,22,25,26,29,30,33,34]);
        swDispCont = [6 4 5 7 8 9];
        SelectPlot2; % 绘制各种信号
        % ... 绘图格式设置 ...
        SetTimePlot_r06; % 生成时域图
        RankBTimePlot; % 生成 Rank B 信号图
        % ... 保存图像 ...
        close(figParaA);
    end
end

% 4. “ParaPara B”绘图生成
if OnlyMF4ParaB == 1
    for PLDListCnt=1:length(chkFlgNameList)
        chkPLDFlgIdxPartTmp = chkPLDFlgIdx(:,PLDListCnt).*(1:length(time))';
        chkPLDFlgIdxPart = chkPLDFlgIdxPartTmp(chkPLDFlgIdxPartTmp~=0);
        % ... PLD 事件分类 (detailClassificationResim) ...
        % ... 绘图循环 (类似 ParaPara A) ...
    end
end


---

## 2.3 PLDoverLap.m
#### 2.3.1 模块说明
`PLDoverLap.m` 脚本旨在识别和处理不同 PLD（感知车道偏离）标志之间的重叠。它接收一组二进制标志信号，查找这些标志处于活动状态的连续间隔，然后分析这些间隔在不同标志类型之间的重叠。最终目标似乎是根据这些重叠和特定的标志组合生成“输出问题”列表。

#### 2.3.2 重点逻辑
1.  **全局变量和初始化：** 声明全局变量 `n` 和 `v`。清除局部变量，并初始化 `n`、`v`、`obj(1)` 和 `obj1(1)`。
2.  **标志处理主循环：** 遍历 `chkFlgNameList` 中的每个标志。
    *   调用 `find_intervals` 查找当前标志的连续活动间隔。
    *   **重叠比较 (`compareObj`)：** 调用 `compareObj` 检测当前间隔与 `obj` 中先前存储的间隔之间的重叠。如果检测到重叠，调用 `myStruct` 更新 `obj`。如果没有重叠，向 `obj` 添加新条目。
3.  **过滤 `obj` 到 `obj1`：** 过滤 `obj`，只保留 `length(obj(i).text)>3` 的条目。
4.  **连续重叠分组 (`findContinuousOverlaps`)：** 调用 `findContinuousOverlaps` 将时间上连续的重叠间隔分组。然后标记属于连续重叠组的间隔。
5.  **生成 `outputList` (`outputIssue`)：** 遍历标记的间隔。如果间隔被标记为连续重叠的一部分，则调用 `outputIssue` 处理。`outputIssue` 递归处理间隔，并根据标志名称和行数向 `outputList` 添加特定条目。
6.  **特定重叠处理：** 检查 `732` 后跟 `728` 标志的特定序列，并相应地添加到 `outputList`。
7.  **最终 `output` 格式化：** 如果 `outputList` 不为空，则将其格式化为字符串数组 `output`。

#### 2.3.3 模块内部交互
`PLDoverLap.m` 脚本调用以下嵌套函数：
*   `find_intervals`：查找连续活动间隔。
*   `findContinuousOverlaps`：分组连续重叠间隔。
*   `compareObj`：比较对象并处理重叠。
*   `myStruct`：修改全局 `obj` 变量。
*   `outputIssue`：生成问题列表。

#### 2.3.4 关键伪代码

matlab
% PLDoverLap.m - PLD 重叠处理脚本

global n v;
clearvars obj obj1;
warning('off','MATLAB:declareGlobalBeforeUse');
n = 1;
v = 0;
obj(1).text = "";
obj(1).length = double(0);
obj(1).startEnd = [0,0];
obj(1).listName = "777";

% 1. 标志处理主循环
for i = 1:10
    col = chkFlgNameList(:,i);
    col = char(col);
    col = col(1:3);
    intervals = find_intervals(chkFlgListTmp(:,i));
    if ~isempty(intervals)
        [a,b] = size(intervals);
        for j = 1:a
            obj = compareObj(intervals(j,:),n,col,obj);
        end
    end
end

% 2. 过滤 obj 到 obj1
obj1(1).text = "";
% ... 过滤逻辑 ...
for i = 2:length(obj1)
    intervals(i-1,1) = obj1(i).startEnd(1,1);
    intervals(i-1,2) = obj1(i).startEnd(1,2);
    intervals(i-1,3) = double(string(obj1(i).listName));
end

if ~isempty(intervals)
    % 3. 连续重叠分组
    [groups, groupIntervals] = findContinuousOverlaps(intervals);
    intervals = sortrows(intervals, 1);
    intervals = num2cell(intervals);
    for i = 1:length(groupIntervals)
        intervals(max(cell2mat(groupIntervals(1,i))),4) = cellstr("1");
    end
    
    % 4. 生成 outputList
    [a,~] = size(intervals);
    startIndex = 1;
    endIndex = 1;
    outputList = [];
    while(endIndex<=a)
        if isequal(intervals(endIndex,4),cellstr("1"))
            outRange = intervals(startIndex:endIndex,1:3);
            [row,col] = size(outRange);
            outputList = outputIssue(outRange,row,outputList);
            startIndex = endIndex + 1;
        end
        endIndex = endIndex + 1;
    end
    
    % 5. 特定重叠处理
    for i = 1:a-1
        if cell2mat(intervals(i,3)) == 732 && cell2mat(intervals(i+1,3)) == 728 && ~isequal(intervals(i,4),cellstr("1"))
            [l,~] = size(outputList);
            outputList(l+1,:) = cell2mat(intervals(i+1,1:3));
        end
    end
    
    % 6. 最终 output 格式化
    if ~isempty(outputList)
        output = transpose(strcat(string(outputList(:,3)),'_',string(outputList(:,1)+1)));
        output = unique(output,'stable');
    else
        output = string([]);
    end
else
    output = string([]);
end

% 嵌套函数 (find_intervals, findContinuousOverlaps, compareObj, myStruct, outputIssue)
% ... (此处省略嵌套函数的伪代码，因为它们在上面已详细描述) ...


---

## 2.4 SelectPlot2.m
#### 2.4.1 模块说明
`SelectPlot2.m` 脚本是绘图函数的集合，旨在可视化车道模型 (LM) 数据的各个方面，包括地图车道、控制车道、相机 C0 轨迹、相机线、PL 路径形状和对象信息。它是一个辅助脚本，由 `createOnlyMF4Parapara.m`（以及其他绘图脚本）调用，用于将特定元素绘制到给定的 `axes` 对象 (`ax99`) 上。

#### 2.4.2 重点逻辑
1.  **车辆矩形：** 在 `ax99` 上绘制一个表示车辆位置和大小的黄色矩形。
2.  **主绘图循环：** 遍历 `swDispCont`（显示内容标志），每个值对应一种特定类型的绘图。
3.  **车道基于绘图：** 对于 `swDispCont` 值 2, 3, 5，绘制地图车道、LM 自定位基于地图车道和 LM 输出地图车道。调用 `plotMapLaneFunc`、`plotLmOutMapLaneFunc`、`plotLmOutMapLineClassFunc`、`plotLmOutMapLaneCtClassFunc`。
4.  **控制车道绘图：** 对于 `swDispCont` 值 4，绘制控制车道。调用 `plotLmOutCtrlLaneFunc`。
5.  **相机 C0 轨迹绘图：** 对于 `swDispCont` 值 6, 61，绘制相机 C0 轨迹。调用 `plotCamC0TraceFunc`。
6.  **LM 输出相机车道绘图：** 对于 `swDispCont` 值 7，绘制 LM 输出相机车道。调用 `plotCamLineFunc`。
7.  **PL 路径形状绘图：** 对于 `swDispCont` 值 8，绘制 PL 路径形状。
8.  **对象信息绘图：** 对于 `swDispCont` 值 9，绘制对象信息。

#### 2.4.3 模块内部交互
`SelectPlot2.m` 脚本调用以下嵌套函数：
*   `plotCamC0TraceFunc`：绘制相机 C0 轨迹。
*   `plotCamLineFunc`：绘制相机线。
*   `plotLmOutCtrlLaneFunc`：绘制 LM 输出控制车道。
*   `plotLmOutMapLaneFunc`：绘制 LM 输出地图车道。
*   `plotLmOutMapLineClassFunc`：绘制 LM 输出地图线。
*   `plotLmOutMapLaneCtClassFunc`：绘制 LM 输出地图车道中心线。
*   `plotMapLaneFunc`：绘制地图车道。

#### 2.4.4 关键伪代码

matlab
% SelectPlot2.m - 绘图函数集合

rectangle(ax99,'Position',[-veclWidth/2 -veclLength/2 veclWidth veclLength],'FaceColor','y');
for i = 1:length(swDispCont)
    if swDispCont(i) == 2 || swDispCont(i) == 3 || swDispCont(i) == 5
        for ln = 0:15
            % ... 颜色和标记设置 ...
            if swDispCont(i) == 2
                % ... 调用 plotMapLaneFunc ...
            end
            if swDispCont(i) == 3
                % ... 调用 plotMapLaneFunc ...
            end
            if swDispCont(i) == 5
                % ... 调用 plotLmOutMapLaneFunc, plotLmOutMapLineClassFunc, plotLmOutMapLaneCtClassFunc ...
            end
        end
    end

    if swDispCont(i) == 4
        % ... 调用 plotLmOutCtrlLaneFunc ...
    end

    if (swDispCont(i) == 6) || (swDispCont(i) == 61)
        % ... 调用 plotCamC0TraceFunc ...
    end

    if swDispCont(i) == 7
        % ... 调用 plotCamLineFunc ...
    end

    if swDispCont(i) == 8
        % ... 绘制 PL path 形状 ...
    end

    if swDispCont(i) == 9
        % ... 绘制物标信息 ...
    end
end

% 嵌套函数 (plotCamC0TraceFunc, plotCamLineFunc, plotLmOutCtrlLaneFunc, plotLmOutMapLaneFunc, plotLmOutMapLineClassFunc, plotLmOutMapLaneCtClassFunc, plotMapLaneFunc)
% ... (此处省略嵌套函数的伪代码，因为它们在上面已详细描述) ...


---

## 2.5 SetTimePlot_r06.m
#### 2.5.1 模块说明
`SetTimePlot_r06.m` 脚本生成一系列 LM 相关信号的时域图（时间图表）。这些图表显示在特定的子图布局中，并提供围绕给定 `timeChartIndex` 的信号行为的详细视图。它还在 `timeChartIndex` 处显示这些信号的关键值。

#### 2.5.2 重点逻辑
1.  **输入 `timeChartIndex`：** 脚本接收 `timeChartIndex` 作为输入，它是绘图中心所在的样本索引。
2.  **时间窗口计算：** 定义绘图的时间窗口 `cutSmpl4save`。
3.  **绘图部分：** 脚本分为多个“MAP”部分，每个部分对应一个不同的子图并显示不同的信号。
    *   **MAP 1 (ax511)：** 绘制 `eMap` 和 `eYRM`。
    *   **MAP 2 (ax512)：** 绘制曲率半径。
    *   **MAP 3 (ax513)：** 绘制自车速度。
    *   **MAP 4 (ax516)：** 绘制车道模式（RightLineMatch, LeftLineMatch, CameraBase, MapBase）。
    *   **MAP 5 (ax517)：** 绘制 PLD 状态。
    *   **MAP 6 (ax518)：** 绘制左侧和右侧 ClinebFlg。
    *   **MAP 7 (ax519)：** 绘制 `tgtDiffy`（Y 轴目标差）。
    *   **MAP 8 (ax520)：** 显示原始信号值的二进制表示。

#### 2.5.3 模块内部交互
`SetTimePlot_r06.m` 脚本不调用其他脚本或函数，仅使用基本的 MATLAB 绘图函数和信号处理。

#### 2.5.4 关键伪代码

matlab
% SetTimePlot_r06.m - 设置时间图

% ... 时间窗口计算 ...

% MAP 1 (ax511): eMap, eYRM
ax511 = subplot(9,4,3);
plot(ax511,time(cutSmpl4save,1),bitget(S_lmInhStt.signals.values(cutSmpl4save,1),3),'r.-'); hold on;
% ... 其他绘图和格式设置 ...

% MAP 2 (ax512): 曲率半径
ax512 = subplot(9,4,7);
plot(ax512,time(cutSmpl4save,1),1./abs(curv(cutSmpl4save,2)),'b.-'); hold on;
% ... 其他绘图和格式设置 ...

% ... (MAP 3 到 MAP 8 类似) ...

% MAP 8 (ax520): 原始信号值的二进制表示
ax520 = subplot(9,4,35);
% ... 显示二进制字符串 ...


---

## 2.6 RankBTimePlot.m
#### 2.6.1 模块说明
`RankBTimePlot.m` 脚本专门为“Rank B”信号生成一系列时域图（时间图表），这些信号可能与基于摄像头的车道检测和质量指标有关。它显示这些图表在特定的子图布局中，并突出显示给定 `timeChartIndex` 处的信号值。

#### 2.6.2 重点逻辑
1.  **数据提取：** 提取 `lmVecClineProbability`、`lmVecClineQuality` 和 `lmVecClineType`。
2.  **时间窗口计算：** 使用 `cutSmpl4save` 定义绘图的时间窗口。
3.  **绘图部分：** 脚本分为多个“Chart”部分，每个部分对应一个不同的子图并显示不同的信号。
    *   **Chart 1 (ax611)：** 绘制左/右摄像头末端 X。
    *   **Chart 2 (ax612)：** 绘制左/右 Cline 概率。
    *   **Chart 3 (ax613)：** 绘制左/右 Cline 质量。
    *   **Chart 4 (ax614)：** 绘制 Cline 类型。
    *   **Chart 5 (ax615)：** 绘制 YRM 状态位。
    *   **Chart 6 (ax616)：** 绘制 PLD 状态位。
    *   **Chart 7 (ax617)：** 绘制 MPU 时间戳差异。
    *   **Chart 8 (ax618)：** 绘制摄像头时间戳同步（已注释掉）。
    *   **Chart 9 (ax619)：** 绘制自车车道索引。

#### 2.6.3 模块内部交互
`RankBTimePlot.m` 脚本不调用其他脚本或函数，仅使用基本的 MATLAB 绘图函数和信号处理。

#### 2.6.4 关键伪代码

matlab
% RankBTimePlot.m - Rank B 信号时间图

lmVecClineProbability = S_MElaneExistenceProb.signals.values;
% ... 其他数据提取 ...

% ... 时间窗口计算 ...

% Chart 1 (ax611): 左/右摄像头末端 X
ax611 = subplot(10,4,4);
plot(ax611,time(cutSmpl4save),S_lmVecClineEndX.signals.values(cutSmpl4save,1),'r.-');hold on;
% ... 其他绘图和格式设置 ...

% Chart 2 (ax612): 左/右 Cline 概率
ax612 = subplot(10,4,8);
plot(ax612,time(cutSmpl4save),lmVecClineProbability(cutSmpl4save,1),'r.-');hold on;
% ... 其他绘图和格式设置 ...

% ... (Chart 3 到 Chart 9 类似) ...

